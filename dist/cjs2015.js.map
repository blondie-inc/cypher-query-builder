{"version":3,"file":"cjs2015.js","sources":["../src/utils.ts","../src/parameter-bag.ts","../src/parameter-container.ts","../src/clause.ts","../src/clauses/pattern.ts","../src/clauses/node-pattern.ts","../src/clauses/relation-pattern.ts","../src/clauses/pattern-clause.ts","../src/clauses/create.ts","../src/clauses/term-list-clause.ts","../src/clauses/with.ts","../src/clauses/unwind.ts","../src/clauses/delete.ts","../src/clauses/set.ts","../src/clauses/match.ts","../src/clauses/remove.ts","../src/clauses/return.ts","../src/clauses/skip.ts","../src/clauses/limit.ts","../src/clauses/where-comparators.ts","../src/clauses/where-utils.ts","../src/clauses/where.ts","../src/clauses/raw.ts","../src/clauses/order-by.ts","../src/clauses/merge.ts","../src/clauses/on-match.ts","../src/clauses/on-create.ts","../src/clauses/where-operators.ts","../src/clauses/index.ts","../src/clauses/union.ts","../src/builder.ts","../src/transformer.ts","../src/clause-collection.ts","../src/query.ts","../src/connection.ts"],"sourcesContent":["import {\n  camelCase,\n  castArray,\n  isArray,\n  isBoolean,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  map,\n  reduce,\n  Many,\n} from 'lodash';\n\n/**\n * Converts a string to camel case and ensures it is unique in the provided\n * list.\n * @param {string} str\n * @param {Array<string>} existing\n * @return {string}\n */\nexport function uniqueString(str: string, existing: string[]) {\n  let camelString = camelCase(str);\n\n  // Check if the string already has a number extension\n  let number = null;\n  const matches = camelString.match(/[0-9]+$/);\n  if (matches) {\n    number = +matches[0];\n    camelString = camelString.substr(0, camelString.length - matches[0].length);\n  }\n\n  // Compute all taken suffixes that are similar to the given string\n  const regex = new RegExp(`^${camelString}([0-9]*)$`);\n  const takenSuffixes = reduce(\n    existing,\n    (suffixes, existingString) => {\n      const matches = existingString.match(regex);\n      if (matches) {\n        const [, suffix] = matches;\n        suffixes.push(suffix ? +suffix : 1);\n      }\n      return suffixes;\n    },\n    [] as number[],\n  );\n\n  // If there was no suffix on the given string or it was already taken,\n  // compute the new suffix.\n  if (!number || takenSuffixes.indexOf(number) !== -1) {\n    number = Math.max(0, ...takenSuffixes) + 1;\n  }\n\n  // Append the suffix if it is not 1\n  return camelString + (number === 1 ? '' : number);\n}\n\n/**\n * Converts a Javascript value into a string suitable for a cypher query.\n * @param {object|Array|string|boolean|number} value\n * @return {string}\n */\nexport function stringifyValue(value: any): string {\n  if (isNumber(value) || isBoolean(value)) {\n    return `${value}`;\n  }\n  if (isString(value)) {\n    return `'${value}'`;\n  }\n  if (isArray(value)) {\n    const str = map(value, stringifyValue).join(', ');\n    return `[ ${str} ]`;\n  }\n  if (isObject(value)) {\n    const pairs = map(value, (el, key) => `${key}: ${stringifyValue(el)}`);\n    const str = pairs.join(', ');\n    return `{ ${str} }`;\n  }\n  return '';\n}\n\n/**\n * Converts labels into a string that can be put into a pattern.\n *\n * @param {string|array<string>} labels\n * @param relation When true, joins labels by a | instead of :\n * @return {string}\n */\nexport function stringifyLabels(labels: Many<string>, relation = false) {\n  if (labels.length === 0) {\n    return '';\n  }\n  return `:${castArray(labels).join(relation ? '|' : ':')}`;\n}\n\nexport type PathLength = '*'\n  | number\n  | [number | null | undefined]\n  | [number | null | undefined, number | null | undefined];\n\n/**\n * Converts a path length bounds into a string to put into a relationship.\n * @param  {Array<int>|int} bounds An array of bounds\n * @return {string}\n */\nexport function stringifyPathLength(bounds?: PathLength): string {\n  if (isNil(bounds)) {\n    return '';\n  }\n\n  if (bounds === '*') {\n    return '*';\n  }\n\n  if (isNumber(bounds)) {\n    return `*${bounds}`;\n  }\n\n  const lower = isNil(bounds[0]) ? '' : `${bounds[0]}`;\n  const upper = isNil(bounds[1]) ? '' : `${bounds[1]}`;\n  return lower || upper ? `*${lower}..${upper}` : '*';\n}\n","import { Dictionary, keys, mapValues } from 'lodash';\nimport { uniqueString } from './utils';\n\nexport class Parameter {\n  constructor(\n    public name: string,\n    public value: string,\n  ) { }\n\n  toString() {\n    return `$${this.name}`;\n  }\n}\n\nexport class ParameterBag {\n  protected parameterMap: Dictionary<Parameter> = {};\n\n  /**\n   * Constructs a unique name for this parameter bag.\n   * @return {string}\n   */\n  getName(name = 'p') {\n    return uniqueString(name, keys(this.parameterMap));\n  }\n\n  /**\n   * Adds a new parameter to this bag.\n   * @param {*} value\n   * @param {string|undefined} name\n   * @return {Parameter} Newly created parameter object.\n   */\n  addParam(value: any, name?: string) {\n    const actualName = this.getName(name);\n    const param = new Parameter(actualName, value);\n    this.parameterMap[actualName] = param;\n    return param;\n  }\n\n  /**\n   * Adds an existing parameter to this bag. The name may be changed if\n   * it is already taken, however, the Parameter object will not be recreated.\n   * @param {Parameter} param\n   * @return {Parameter}\n   */\n  addExistingParam(param: Parameter) {\n    param.name = this.getName(param.name);\n    this.parameterMap[param.name] = param;\n    return param;\n  }\n\n  /**\n   * Returns the params in a name: value object suitable for putting into a\n   * query object.\n   * @return {object}\n   */\n  getParams(): Dictionary<any> {\n    return mapValues(this.parameterMap, 'value');\n  }\n\n  /**\n   * Removes a parameter from the internal map.\n   * @param {string} name\n   */\n  deleteParam(name: string) {\n    delete this.parameterMap[name];\n  }\n\n  /**\n   * Copies all parameters from another bag into this bag.\n   */\n  importParams(other: ParameterBag) {\n    for (const key in other.parameterMap) {\n      this.addExistingParam(other.parameterMap[key]);\n    }\n  }\n\n  /**\n   * Returns a parameter with the given name.\n   */\n  getParam(name: string) {\n    return this.parameterMap[name];\n  }\n}\n","import { Parameter, ParameterBag } from './parameter-bag';\nimport { Dictionary } from 'lodash';\n\nexport class ParameterContainer {\n  protected parameterBag = new ParameterBag();\n\n  useParameterBag(newBag: ParameterBag) {\n    newBag.importParams(this.parameterBag);\n    this.parameterBag = newBag;\n  }\n\n  getParams(): Dictionary<any> {\n    return this.parameterBag.getParams();\n  }\n\n  /**\n   * Adds a new parameter to the bag.\n   * @param {*} value\n   * @param {string|undefined} name\n   * @return {Parameter} Newly created parameter object.\n   */\n  addParam(value: any, name?: string): Parameter {\n    return this.parameterBag.addParam(value, name);\n  }\n\n  getParameterBag() {\n    return this.parameterBag;\n  }\n}\n","import { stringifyValue } from './utils';\nimport { ParameterContainer } from './parameter-container';\nimport { Dictionary } from 'lodash';\n\nexport type QueryObject = {\n  query: string;\n  params: Dictionary<any>\n};\n\nexport abstract class Clause extends ParameterContainer {\n  /**\n   * Turns the clause into a query string.\n   * @return {string} Partial query string.\n   */\n  abstract build(): string;\n\n  /**\n   * Turns the clause into a query string.\n   * @return {string} Partial query string.\n   */\n  toString(): string {\n    return this.build();\n  }\n\n  /**\n   * Turns the clause into a query object.\n   * @return {object} Query object with two parameters: query and params.\n   */\n  buildQueryObject(): QueryObject {\n    return {\n      query: this.build(),\n      params: this.getParams(),\n    };\n  }\n\n  /**\n   * Turns the clause into a query string with parameters\n   * interpolated into the string. For debugging purposes only.\n   * @return {string}\n   */\n  interpolate(): string {\n    let query = this.build();\n    const params = this.getParams();\n    for (const name in params) {\n      const pattern = new RegExp(`\\\\$${name}(?![a-zA-Z0-9_])`, 'g');\n      query = query.replace(pattern, stringifyValue(params[name]));\n    }\n    return query;\n  }\n}\n","import {\n  mapValues, map, isEmpty, Dictionary, isArray, isString,\n  castArray, isObjectLike, isNil, Many,\n} from 'lodash';\nimport { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\nimport { stringifyLabels } from '../utils';\n\nexport abstract class Pattern extends Clause {\n  protected useExpandedConditions: boolean | undefined;\n  protected conditionParams: Dictionary<Parameter> | Parameter = {};\n  protected name: string;\n  protected labels: string[];\n  protected conditions: Dictionary<any>;\n\n  constructor(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n    protected options = { expanded: true },\n  ) {\n    super();\n    const isConditions = (a: any): a is Dictionary<any> => isObjectLike(a) && !isArray(a);\n    let tempName = name;\n    let tempLabels = labels;\n    let tempConditions = conditions;\n\n    if (isNil(tempConditions)) {\n      if (isConditions(tempLabels)) {\n        tempConditions = tempLabels;\n        tempLabels = undefined;\n      } else if (isNil(tempLabels) && isConditions(tempName)) {\n        tempConditions = tempName;\n        tempName = undefined;\n      } else {\n        tempConditions = {};\n      }\n    }\n\n    if (isNil(tempLabels)) {\n      if (isArray(tempName)) {\n        tempLabels = tempName;\n        tempName = undefined;\n      } else {\n        tempLabels = [];\n      }\n    }\n\n    if (isNil(tempName)) {\n      tempName = '';\n    }\n\n    if (!isString(tempName)) {\n      throw new TypeError('Name must be a string.');\n    }\n    if (!isString(tempLabels) && !isArray(tempLabels)) {\n      throw new TypeError('Labels must be a string or an array');\n    }\n    if (!isConditions(tempConditions)) {\n      throw new TypeError('Conditions must be an object.');\n    }\n\n    this.labels = castArray(tempLabels);\n    this.name = tempName;\n    this.conditions = tempConditions;\n    this.setExpandedConditions(options.expanded);\n  }\n\n  setExpandedConditions(expanded: boolean) {\n    if (this.useExpandedConditions !== expanded) {\n      this.useExpandedConditions = expanded;\n      this.rebindConditionParams();\n    }\n  }\n\n  rebindConditionParams() {\n    // Delete old bindings\n    if (this.conditionParams instanceof Parameter) {\n      this.parameterBag.deleteParam(this.conditionParams.name);\n    } else {\n      for (const key in this.conditionParams) {\n        this.parameterBag.deleteParam(this.conditionParams[key].name);\n      }\n    }\n\n    // Rebind params\n    if (!isEmpty(this.conditions)) {\n      if (this.useExpandedConditions) {\n        this.conditionParams = mapValues(this.conditions, (value, name) => {\n          return this.parameterBag.addParam(value, name);\n        });\n      } else {\n        this.conditionParams = this.parameterBag.addParam(this.conditions, 'conditions');\n      }\n    } else {\n      this.conditionParams = {};\n    }\n  }\n\n  getNameString() {\n    return this.name ? this.name : '';\n  }\n\n  getLabelsString(relation = false) {\n    return stringifyLabels(this.labels, relation);\n  }\n\n  getConditionsParamString() {\n    if (isEmpty(this.conditions)) {\n      return '';\n    }\n\n    if (this.useExpandedConditions) {\n      const strings = map(this.conditionParams, (param, name) => {\n        return `${name}: ${param}`;\n      });\n      return `{ ${strings.join(', ')} }`;\n    }\n    return this.conditionParams.toString();\n  }\n}\n","import { Dictionary, Many, trim } from 'lodash';\nimport { Pattern } from './pattern';\n\nexport class NodePattern extends Pattern {\n  constructor(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    super(name, labels, conditions);\n  }\n\n  build() {\n    let query = this.getNameString();\n    query += this.getLabelsString();\n    query += ` ${this.getConditionsParamString()}`;\n    return `(${trim(query)})`;\n  }\n}\n","import { Dictionary, trim, Many, isNil, isNumber, isArray, every } from 'lodash';\nimport { Pattern } from './pattern';\nimport { PathLength, stringifyPathLength } from '../utils';\n\nconst isPathLengthArray = (value: any) => (\n  isArray(value) && every(value, item => isNumber(item) || isNil(item)) && value.length > 0\n);\nconst isPathLength = (value: any): value is PathLength => (\n  value === '*' || isNumber(value) || isPathLengthArray(value)\n);\n\nexport type RelationDirection = 'in' | 'out' | 'either';\n\nexport class RelationPattern extends Pattern {\n  dir: RelationDirection;\n  length: PathLength | undefined;\n\n  constructor(\n    dir: RelationDirection,\n    name?: Many<string> | Dictionary<any> | PathLength,\n    labels?: Many<string> | Dictionary<any> | PathLength,\n    conditions?: Dictionary<any> | PathLength,\n    length?: PathLength,\n  ) {\n    let tempName = name;\n    let tempLabels = labels;\n    let tempConditions = conditions;\n    let tempLength = length;\n\n    if (isNil(tempLength)) {\n      if (isPathLength(tempConditions)) {\n        tempLength = tempConditions;\n        tempConditions = undefined;\n      } else if (isNil(tempConditions) && isPathLength(tempLabels)) {\n        tempLength = tempLabels;\n        tempLabels = undefined;\n      } else if (isNil(tempConditions) && isNil(tempLabels) && isPathLength(tempName)) {\n        tempLength = tempName;\n        tempName = undefined;\n      }\n    }\n\n    if (isPathLength(tempName) || isPathLength(tempLabels) || isPathLength(tempConditions)) {\n      throw new TypeError('Invalid argument combination.');\n    }\n\n    super(tempName, tempLabels, tempConditions);\n    this.dir = dir;\n    this.length = tempLength;\n  }\n\n  build() {\n    const name = this.getNameString();\n    const labels = this.getLabelsString(true);\n    const length = stringifyPathLength(this.length);\n    const conditions = this.getConditionsParamString();\n    const query = trim(`${name}${labels}${length} ${conditions}`);\n\n    const arrows: Record<'in' | 'out' | 'either', string[]> = {\n      in: ['<-', '-'],\n      out: ['-', '->'],\n      either: ['-', '-'],\n    };\n    return arrows[this.dir].join(query.length > 0 ? `[${query}]` : '');\n  }\n}\n","import { reduce, map, assign, castArray, isArray } from 'lodash';\nimport { Pattern } from './pattern';\nimport { Clause } from '../clause';\n\nexport interface PatternOptions {\n  useExpandedConditions?: boolean;\n}\n\nexport type PatternCollection = Pattern | Pattern[] | Pattern[][];\n\nexport class PatternClause extends Clause {\n  protected patterns: Pattern[][];\n\n  constructor(\n    patterns: PatternCollection,\n    options: PatternOptions = { useExpandedConditions: false },\n  ) {\n    super();\n    const defaultOptions = {\n      useExpandedConditions: true,\n    };\n    const { useExpandedConditions } = assign(defaultOptions, options);\n\n    // Ensure patterns is a two dimensional array.\n    const arr = castArray<Pattern | Pattern[]>(patterns);\n    this.patterns = (isArray(arr[0]) ? arr : [arr]) as Pattern[][];\n\n    // Add child patterns as clauses\n    this.patterns.forEach(arr => arr.forEach((pat) => {\n      pat.setExpandedConditions(useExpandedConditions);\n      pat.useParameterBag(this.parameterBag);\n    }));\n  }\n\n  build() {\n    const patternStrings = map(this.patterns, (pattern) => {\n      return reduce(pattern, (str, clause) => str + clause.build(), '');\n    });\n    return patternStrings.join(', ');\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport interface CreateOptions {\n  unique?: boolean;\n}\n\nexport class Create extends PatternClause {\n  constructor(patterns: PatternCollection, protected options: CreateOptions = {}) {\n    super(patterns, { useExpandedConditions: false });\n  }\n\n  build() {\n    const unique = this.options.unique ? ' UNIQUE' : '';\n    return `CREATE${unique} ${super.build()}`;\n  }\n}\n","import {\n  flatMapDeep,\n  map,\n  isPlainObject,\n  isString,\n  isArray,\n  castArray,\n  reduce,\n  Dictionary,\n  Many,\n} from 'lodash';\nimport { Clause } from '../clause';\n\nexport type Properties = (string | Dictionary<string>)[];\nexport type Term\n  = string\n  | Dictionary<string>\n  | Dictionary<Properties>;\n\nexport class TermListClause extends Clause {\n  protected terms: Term[];\n\n  /**\n   * Accepts:\n   *   node -> string\n   *   many nodes -> string[]\n   *   nodes with aliases -> Dictionary<string>\n   *   node properties -> Dictionary<string[]>\n   *   node properties with aliases -> Dictionary<Dictionary<string>[]>\n   * or an array of any combination\n   */\n  constructor(terms: Many<Term>) {\n    super();\n    this.terms = castArray(terms);\n  }\n\n  toString() {\n    return flatMapDeep(this.terms, term => this.stringifyTerm(term)).join(', ');\n  }\n\n  private stringifyTerm(term: Term): Many<string> {\n    // Just a node\n    if (isString(term)) {\n      return this.stringifyProperty(term);\n    }\n\n    // List of nodes\n    if (isArray(term)) {\n      return this.stringifyProperties(term);\n    }\n\n    // Node properties or aliases\n    if (isPlainObject(term)) {\n      return this.stringifyDictionary(term);\n    }\n\n    return '';\n  }\n\n  private stringifyProperty(prop: string, alias?: string, node?: string): string {\n    let prefix = node ? `${node}.` : '';\n    if (alias) {\n      prefix += `${alias} AS `;\n    }\n    return prefix + prop;\n  }\n\n  private stringifyProperties(props: Properties, alias?: string, node?: string): string[] {\n    const convertToString = (list: string[], prop: string | Dictionary<string>) => {\n      if (isString(prop)) {\n        // Single node property\n        list.push(this.stringifyProperty(prop, alias, node));\n      } else {\n        // Node properties with aliases\n        list.push(...map(prop, (name, alias) => this.stringifyProperty(name, alias, node)));\n      }\n      return list;\n    };\n    return reduce(props, convertToString, []);\n  }\n\n  private stringifyDictionary(node: Dictionary<string | Properties>): string[] {\n    return reduce(\n      node,\n      (list, prop, key) => {\n        if (isString(prop)) {\n          // Alias\n          list.push(this.stringifyProperty(prop, key));\n        } else {\n          // Node with properties\n          list.push(...this.stringifyProperties(prop, undefined, key));\n        }\n        return list;\n      },\n      [] as string[],\n    );\n  }\n\n  build() {\n    return this.toString();\n  }\n}\n","import { Many } from 'lodash';\nimport { Term, TermListClause } from './term-list-clause';\n\nexport class With extends TermListClause {\n  /**\n   * Creates a with clause\n   * @param  {string|object|array<string|object>} terms\n   */\n  constructor(terms: Many<Term>) {\n    super(terms);\n  }\n\n  build() {\n    return `WITH ${super.build()}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Unwind extends Clause {\n  protected listParam: Parameter;\n\n  constructor(\n    protected list: any[],\n    protected name: string,\n  ) {\n    super();\n    this.listParam = this.parameterBag.addParam(this.list, 'list');\n  }\n\n  build() {\n    return `UNWIND ${this.listParam} AS ${this.name}`;\n  }\n}\n","import { Many, castArray } from 'lodash';\nimport { Clause } from '../clause';\n\nexport interface DeleteOptions {\n  detach?: boolean;\n}\n\nexport class Delete extends Clause {\n  variables: string[];\n\n  constructor(\n    variables: Many<string>,\n    protected options: DeleteOptions = { },\n  ) {\n    super();\n    this.variables = castArray(variables);\n  }\n\n  build() {\n    const detach = this.options.detach ? 'DETACH ' : '';\n    return `${detach}DELETE ${this.variables.join(', ')}`;\n  }\n}\n","import {\n  concat, map, mapValues, castArray, Dictionary,\n  Many, isObject, isString,\n} from 'lodash';\nimport { Clause } from '../clause';\nimport { stringifyLabels } from '../utils';\nimport { Parameter } from '../parameter-bag';\n\nexport type SetProperties = {\n  labels?: Dictionary<Many<string>>,\n  values?: Dictionary<any>,\n  variables?: Dictionary<string | Dictionary<string>>,\n};\n\nexport interface SetOptions {\n  merge?: boolean;\n}\n\nexport class Set extends Clause {\n  protected labels: Dictionary<string[]>;\n  protected values: Dictionary<Parameter>;\n  protected variables: Dictionary<string | Dictionary<string>>;\n  protected merge: boolean;\n\n  protected makeLabelStatement = (labels: Many<string>, key: string) => {\n    return key + stringifyLabels(labels);\n  }\n\n  protected makeValueStatement = (value: any, key: string): string => {\n    const valueIsObject = value instanceof Parameter ? isObject(value.value) : isObject(value);\n    const op = this.merge && valueIsObject ? ' += ' : ' = ';\n    return key + op + value;\n  }\n\n  protected makeVariableStatement = (value: string | Dictionary<string>, key: string): string => {\n    const op = this.merge ? ' += ' : ' = ';\n    if (isString(value)) {\n      return key + op + value;\n    }\n    const operationStrings = map(value, (value, prop) => `${key}.${prop}${op}${value}`);\n    return operationStrings.join(', ');\n  }\n\n  constructor(\n    { labels, values, variables }: SetProperties,\n    options: SetOptions = {},\n  ) {\n    super();\n\n    this.labels = mapValues(labels, castArray);\n    this.values = mapValues(values, (value, name) => {\n      return this.parameterBag.addParam(value, name);\n    });\n    this.variables = variables || {};\n    this.merge = !!options.merge;\n  }\n\n  build() {\n    const labels = map(this.labels, this.makeLabelStatement);\n    const values = map(this.values, this.makeValueStatement);\n    const variables = map(this.variables, this.makeVariableStatement);\n    return `SET ${concat(labels, values, variables).join(', ')}`;\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport interface MatchOptions {\n  optional?: boolean;\n}\n\nexport class Match extends PatternClause {\n  constructor(\n    patterns: PatternCollection,\n    protected options: MatchOptions = { optional: false },\n  ) {\n    super(patterns, { useExpandedConditions: true });\n  }\n\n  build() {\n    let str = 'MATCH ';\n    if (this.options.optional) {\n      str = `OPTIONAL ${str}`;\n    }\n    return str + super.build();\n  }\n}\n","import { Clause } from '../clause';\nimport { Dictionary, Many, map, mapValues, flatMap, castArray } from 'lodash';\nimport { stringifyLabels } from '../utils';\n\nexport type RemoveProperties = {\n  labels?: Dictionary<Many<string>>;\n  properties?: Dictionary<Many<string>>;\n};\n\nexport class Remove extends Clause {\n  protected labels: Dictionary<string[]>;\n  protected properties: Dictionary<string[]>;\n\n  constructor({ labels = {}, properties = {} }: RemoveProperties) {\n    super();\n    this.labels = mapValues(labels, castArray);\n    this.properties = mapValues(properties, castArray);\n  }\n\n  build() {\n    const labels = map(this.labels, (labels, key) => key + stringifyLabels(labels));\n    const properties = flatMap(this.properties, (properties, key) => (\n      map(properties, property => `${key}.${property}`)\n    ));\n    return `REMOVE ${[...labels, ...properties].join(', ')}`;\n  }\n}\n","import { Many } from 'lodash';\nimport { Term, TermListClause } from './term-list-clause';\n\nexport interface ReturnOptions {\n  distinct?: boolean;\n}\n\nexport class Return extends TermListClause {\n  constructor(terms: Many<Term>, protected options: ReturnOptions = {}) {\n    super(terms);\n  }\n\n  build() {\n    const distinct = this.options.distinct ? ' DISTINCT' : '';\n    return `RETURN${distinct} ${super.build()}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Skip extends Clause {\n  protected amountParam: Parameter;\n\n  constructor(public amount: number) {\n    super();\n    this.amountParam = this.addParam(amount, 'skipCount');\n  }\n\n  build() {\n    return `SKIP ${this.amountParam}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Limit extends Clause {\n  protected amountParam: Parameter;\n\n  constructor(public amount: number) {\n    super();\n    this.amountParam = this.addParam(amount, 'limitCount');\n  }\n\n  build() {\n    return `LIMIT ${this.amountParam}`;\n  }\n}\n","import { last, capitalize } from 'lodash';\nimport { ParameterBag } from '../parameter-bag';\n\nexport const comparisions = {\n  equals,\n  greaterThan,\n  greaterEqualTo,\n  lessThan,\n  lessEqualTo,\n  startsWith,\n  endsWith,\n  contains,\n  inArray,\n  hasLabel,\n  exists,\n  between,\n  isNull,\n  regexp,\n};\n\nexport type Comparator = (params: ParameterBag, name: string) => string;\n\nfunction compare(operator: string, value: any, variable?: boolean, paramName?: string): Comparator {\n  return (params: ParameterBag, name: string): string => {\n    const baseParamName = paramName || last(name.split('.'));\n    const parts = [\n      name,\n      operator,\n      variable ? value : params.addParam(value, baseParamName),\n    ];\n    return parts.join(' ');\n  };\n}\n\n/**\n * Equals comparator for use in where clauses. This is the default so you will\n * probably never need to use this.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: equals(18) })\n * // WHERE age = 18\n *\n * query.where({ name: equals('clientName', true) })\n * // WHERE age = clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function equals(value: any, variable?: boolean) {\n  return compare('=', value, variable);\n}\n\n/**\n * Greater than comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: greaterThan(18) })\n * // WHERE age > 18\n *\n * query.where({ age: greaterThan('clientAge', true) })\n * // WHERE age > clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function greaterThan(value: any, variable?: boolean) {\n  return compare('>', value, variable);\n}\n\n/**\n * Greater or equal to comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: greaterEqualTo(18) })\n * // WHERE age >= 18\n *\n * query.where({ age: greaterEqualTo('clientAge', true) })\n * // WHERE age >= clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function greaterEqualTo(value: any, variable?: boolean) {\n  return compare('>=', value, variable);\n}\n\n/**\n * Less than comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: lessThan(18) })\n * // WHERE age < 18\n *\n * query.where({ age: lessThan('clientAge', true) })\n * // WHERE age < clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function lessThan(value: any, variable?: boolean) {\n  return compare('<', value, variable);\n}\n\n/**\n * Less or equal to comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: lessEqualTo(18) })\n * // WHERE age <= 18\n *\n * query.where({ age: lessEqualTo('clientAge', true) })\n * // WHERE age >= clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function lessEqualTo(value: any, variable?: boolean) {\n  return compare('<=', value, variable);\n}\n\n/**\n * Starts with comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: startsWith('steve') })\n * // WHERE name STARTS WITH 'steve'\n *\n * query.where({ name: startsWith('clientName', true) })\n * // WHERE name STARTS WITH clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function startsWith(value: string, variable?: boolean) {\n  return compare('STARTS WITH', value, variable);\n}\n\n/**\n * Ends with comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: endsWith('steve') })\n * // WHERE name ENDS WITH 'steve'\n *\n * query.where({ name: endsWith('clientName', true) })\n * // WHERE name ENDS WITH clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function endsWith(value: string, variable?: boolean) {\n  return compare('ENDS WITH', value, variable);\n}\n\n/**\n * Contains comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: contains('steve') })\n * // WHERE name CONTAINS 'steve'\n *\n * query.where({ name: contains('clientName', true) })\n * // WHERE name CONTAINS clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function contains(value: string, variable?: boolean) {\n  return compare('CONTAINS', value, variable);\n}\n\n/**\n * In comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: inArray([ 'steve', 'william' ]) })\n * // WHERE name IN [ 'steve', 'william' ]\n *\n * query.where({ name: inArray('clientNames', true) })\n * // WHERE name IN clientNames\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function inArray(value: any[], variable?: boolean) {\n  return compare('IN', value, variable);\n}\n\n/**\n * Regexp comparator for use in where clauses. Also accepts a case insensitive\n * to make it easier to add the `'(?i)'` flag to the start of your regexp.\n * If you are already using flags in your regexp, you should not set insensitive\n * to true because it will prepend `'(?i)'` which will make your regexp\n * malformed.\n *\n * For convenience you can also pass a Javascript RegExp object into this\n * comparator, which will then be converted into a string before it is\n * passed to cypher. *However*, beware that the cypher regexp syntax is\n * inherited from [java]{@link\n * https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html},\n * and may have slight differences to the Javascript syntax. For example,\n * Javascript RegExp flags will not be preserved when sent to cypher.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: regexp('s.*e') })\n * // WHERE name =~ 's.*e'\n *\n * query.where({ name: regexp('s.*e', true) })\n * // WHERE name =~ '(?i)s.*e'\n *\n * query.where({ name: regexp('clientPattern', false, true) })\n * // WHERE name =~ clientPattern\n * ```\n * @param exp\n * @param insensitive\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function regexp(exp: string | RegExp, insensitive?: boolean, variable?: boolean) {\n  let stringExp = exp;\n  if (exp instanceof RegExp) {\n    // Convert regular expression to string and strip slashes and trailing flags.\n    // This regular expression will always match something so we can use the ! operator to ignore\n    // type errors.\n    stringExp = exp.toString().match(/\\/(.*)\\/[a-z]*/)![1];\n  }\n  return compare('=~', insensitive ? `(?i)${stringExp}` : stringExp, variable);\n}\n\n/**\n * Between comparator for use in where clauses. This comparator uses Neo4j's\n * shortcut comparison syntax: `18 <= age <= 65`.\n *\n * The `lower` and `upper` are the bounds of the comparison. You can use\n * `lowerInclusive` and `upperInclusive` to control whether it uses `<=` or `<`\n * for the comparison. They both default to `true`.\n *\n * If you pass only `lowerInclusive` then it will use that value for both.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: between(18, 65) })\n * // WHERE age >= 18 AND age <= 65\n *\n * query.where({ age: between(18, 65, false) })\n * // WHERE age > 18 < AND age < 65\n *\n * query.where({ age: between(18, 65, true, false) })\n * // WHERE age >= 18 AND age < 65\n *\n * query.where({ age: between('lowerBound', 'upperBound', true, false, true) })\n * // WHERE age >= lowerBound AND age < upperBound\n * ```\n *\n * @param lower\n * @param upper\n * @param {boolean} lowerInclusive\n * @param {boolean} upperInclusive\n * @param {boolean} variables\n * @returns {Comparator}\n */\nexport function between(\n  lower: any,\n  upper: any,\n  lowerInclusive = true,\n  upperInclusive = lowerInclusive,\n  variables?: boolean,\n): Comparator {\n  const lowerOp = lowerInclusive ? '>=' : '>';\n  const upperOp = upperInclusive ? '<=' : '<';\n  return (params: ParameterBag, name) => {\n    const paramName = capitalize(name);\n    const lowerComparator = compare(lowerOp, lower, variables, `lower${paramName}`);\n    const upperComparator = compare(upperOp, upper, variables, `upper${paramName}`);\n\n    const lowerConstraint = lowerComparator(params, name);\n    const upperConstraint = upperComparator(params, name);\n    return `${lowerConstraint} AND ${upperConstraint}`;\n  };\n}\n\n/**\n * Is null comparator for use in where clauses. Note that this comparator does\n * not accept any arguments\n *\n * ```\n * query.where({ name: isNull() })\n * // WHERE name IS NULL\n * ```\n * @returns {Comparator}\n */\nexport function isNull(): Comparator {\n  return (params, name) => `${name} IS NULL`;\n}\n\n/**\n * Has label comparator for use in where clauses.\n *\n * ```\n * query.where({ person: hasLabel('Manager') })\n * // WHERE person:Manager\n * ```\n * @param {string} label\n * @returns {Comparator}\n */\nexport function hasLabel(label: string): Comparator {\n  return (params, name) => `${name}:${label}`;\n}\n\n/**\n * Exists comparator for use in where clauses. Note that this comparator does\n * not accept any arguments\n *\n * ```\n * query.where({ person: exists() })\n * // WHERE exists(person)\n * ```\n * @returns {Comparator}\n */\nexport function exists(): Comparator {\n  return (params, name) => `exists(${name})`;\n}\n","import {\n  Dictionary,\n  isPlainObject,\n  Many,\n  isArray,\n  map,\n  last,\n  keys,\n  isFunction,\n  isRegExp,\n} from 'lodash';\nimport { ParameterBag } from '../parameter-bag';\nimport { Comparator, regexp } from './where-comparators';\n\nexport type Condition = any | Comparator;\nexport type Conditions = Dictionary<Many<Condition>>;\nexport type NodeConditions = Dictionary<Many<Conditions>>;\nexport type AnyConditions = Many<NodeConditions | Conditions | Condition>;\nexport type AndConditions = NodeConditions | Conditions;\nexport type OrConditions = (NodeConditions | Conditions | Condition)[];\n\nexport const enum Precedence {\n  None,\n  Or,\n  Xor,\n  And,\n  Not,\n}\n\nexport abstract class WhereOp {\n  abstract evaluate(params: ParameterBag, precedence?: Precedence, name?: string): string;\n}\n\nexport function stringifyCondition(\n  params: ParameterBag,\n  condition: Condition,\n  name: string = '',\n): string {\n  if (isFunction(condition)) {\n    return condition(params, name);\n  }\n  const conditionName = last(name.split('.'));\n  return `${name} = ${params.addParam(condition, conditionName)}`;\n}\n\nexport function stringCons(\n  params: ParameterBag,\n  conditions: Many<NodeConditions | Conditions | Condition>,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  if (isArray(conditions)) {\n    return combineOr(params, conditions, precedence, name);\n  }\n  if (isPlainObject(conditions)) {\n    return combineAnd(params, conditions, precedence, name);\n  }\n  if (conditions instanceof WhereOp) {\n    return conditions.evaluate(params, precedence, name);\n  }\n  if (isRegExp(conditions)) {\n    return stringifyCondition(params, regexp(conditions), name);\n  }\n  return stringifyCondition(params, conditions, name);\n}\n\nexport function combineNot(\n  params: ParameterBag,\n  conditions: AnyConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  const string = `NOT ${stringCons(params, conditions, Precedence.Not, name)}`;\n  const braces = precedence !== Precedence.None && precedence > Precedence.Not;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineOr(\n  params: ParameterBag,\n  conditions: OrConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = conditions.length < 2 ? precedence : Precedence.Or;\n  const strings = map(conditions, condition => stringCons(params, condition, newPrecedence, name));\n\n  const string = strings.join(' OR ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineXor(\n  params: ParameterBag,\n  conditions: OrConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = conditions.length < 2 ? precedence : Precedence.Xor;\n  const strings = map(conditions, condition => stringCons(params, condition, newPrecedence, name));\n\n  const string = strings.join(' XOR ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineAnd(\n  params: ParameterBag,\n  conditions: AndConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // Prepare name to be joined with the key of the object\n  const namePrefix = name.length > 0 ? `${name}.` : '';\n\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = keys(conditions).length < 2 ? precedence : Precedence.And;\n  const strings = map(conditions, (condition, key) => {\n    return stringCons(params, condition, newPrecedence, namePrefix + key);\n  });\n\n  const string = strings.join(' AND ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n","import { Clause } from '../clause';\nimport { AnyConditions, stringCons } from './where-utils';\n\nexport class Where extends Clause {\n  constructor(public conditions: AnyConditions) {\n    super();\n  }\n\n  build() {\n    return `WHERE ${stringCons(this.parameterBag, this.conditions)}`;\n  }\n}\n","import {\n  isString,\n  isArray,\n  isObjectLike,\n  map,\n  flatten,\n  zip,\n  isNil,\n} from 'lodash';\nimport { Clause } from '../clause';\n\nexport class Raw extends Clause {\n  clause: string;\n\n  constructor(clause: string | TemplateStringsArray, ...args: any[]) {\n    super();\n\n    if (isString(clause)) {\n      this.clause = clause;\n      const params = args[0];\n      if (isObjectLike(params)) {\n        for (const key in params) {\n          if (Object.hasOwnProperty.call(params, key)) {\n            this.addParam(params[key], key);\n          }\n        }\n      } else if (!isNil(params)) {\n        throw new TypeError('When passing a string clause to Raw, params should be an object');\n      }\n    } else if (isArray(clause)) {\n      const queryParams = map(args, param => this.addParam(param));\n      this.clause = flatten(zip(clause, queryParams)).join('');\n    } else {\n      throw new TypeError('Clause should be a string or an array');\n    }\n  }\n\n  build() {\n    return this.clause;\n  }\n}\n","import { map, isString, isArray, Dictionary, trim } from 'lodash';\nimport { Clause } from '../clause';\n\nexport type Direction = boolean\n  | 'DESC'\n  | 'desc'\n  | 'DESCENDING'\n  | 'descending'\n  | 'ASC'\n  | 'asc'\n  | 'ASCENDING'\n  | 'ascending'\n  | null\n  | undefined;\nexport type InternalDirection = 'DESC' | '';\nexport type OrderConstraint = [string, Direction] | [string];\nexport type InternalOrderConstraint = { field: string, direction: InternalDirection };\nexport type OrderConstraints = Dictionary<Direction>;\n\nexport class OrderBy extends Clause {\n  constraints: InternalOrderConstraint[];\n\n  constructor(fields: string | (string | OrderConstraint)[] | OrderConstraints, dir?: Direction) {\n    super();\n    const direction = OrderBy.normalizeDirection(dir);\n\n    if (isString(fields)) {\n      this.constraints = [{ direction, field: fields }];\n    } else if (isArray(fields)) {\n      this.constraints = map(fields, (field): InternalOrderConstraint => {\n        if (!isArray(field)) {\n          return { field, direction };\n        }\n        const fieldDirection = field[1] ? OrderBy.normalizeDirection(field[1]) : direction;\n        return { field: field[0], direction: fieldDirection };\n      });\n    } else {\n      this.constraints = map(fields, (fieldDirection, field) => {\n        return { field, direction: OrderBy.normalizeDirection(fieldDirection) };\n      });\n    }\n  }\n\n  build() {\n    const constraints = map(this.constraints, ({ field, direction }) => {\n      return trim(`${field} ${direction}`);\n    });\n    return `ORDER BY ${constraints.join(', ')}`;\n  }\n\n  private static normalizeDirection(dir?: Direction | string): InternalDirection {\n    const upperDir = typeof dir === 'string' ? dir.toUpperCase() : dir;\n    const isDescending = upperDir === 'DESC' || upperDir === 'DESCENDING' || upperDir === true;\n    return isDescending ? 'DESC' : '';\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport class Merge extends PatternClause {\n  constructor(\n    patterns: PatternCollection,\n  ) {\n    super(patterns, { useExpandedConditions: true });\n  }\n\n  build() {\n    return `MERGE ${super.build()}`;\n  }\n}\n","import { Set } from './set';\nimport { Clause } from '../clause';\n\nexport class OnMatch extends Clause {\n  constructor(protected clause: Set) {\n    super();\n    clause.useParameterBag(this.parameterBag);\n  }\n\n  build() {\n    return `ON MATCH ${this.clause.build()}`;\n  }\n}\n","import { Set } from './set';\nimport { Clause } from '../clause';\n\nexport class OnCreate extends Clause {\n  constructor(protected clause: Set) {\n    super();\n    clause.useParameterBag(this.parameterBag);\n  }\n\n  build() {\n    return `ON CREATE ${this.clause.build()}`;\n  }\n}\n","import {\n  AndConditions,\n  AnyConditions,\n  combineAnd,\n  combineNot,\n  combineOr,\n  combineXor,\n  OrConditions,\n  Precedence,\n  WhereOp,\n} from './where-utils';\nimport { ParameterBag } from '../parameter-bag';\n\nexport const operators = { and, or, xor, not };\n\n/**\n * `AND` operator to use in where clauses. This is the default operator when\n * using conditions so you will probably never need to use this unless you'd\n * like to make it explicit.\n *\n * ```\n * query.where(and({\n *   'person.name': 'Steve',\n *   'person.age': greaterThan(18),\n * }));\n * // WHERE person.name = 'Steve' AND person.age > 18\n * ```\n * Note that this method only accepts a dictionary of conditions.\n *\n * @param {AndConditions} conditions\n * @returns {WhereAnd}\n */\nexport function and(conditions: AndConditions) {\n  return new WhereAnd(conditions);\n}\n\nexport class WhereAnd extends WhereOp {\n  constructor(protected conditions: AndConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineAnd(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `OR` operator to use in where clauses. This is the default operator when\n * supplying an array to where so you will probably never need to use this\n * unless you'd like to make it explicit.\n *\n * ```\n * query.where(or([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE person.name = 'Steve' OR person.age > 18\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereOr}\n */\nexport function or(conditions: OrConditions) {\n  return new WhereOr(conditions);\n}\n\nexport class WhereOr extends WhereOp {\n  constructor(protected conditions: OrConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineOr(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `XOR` operator to use in where clauses.\n *\n * ```\n * query.where(xor([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE person.name = 'Steve' XOR person.age > 18\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereXor}\n */\nexport function xor(conditions: OrConditions) {\n  return new WhereXor(conditions);\n}\n\nexport class WhereXor extends WhereOp {\n  constructor(protected conditions: OrConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineXor(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `NOT` operator to use in where clauses.\n *\n * ```\n * query.where(not([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE NOT (person.name = 'Steve' AND person.age > 18)\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereXor}\n */\nexport function not(conditions: AnyConditions) {\n  return new WhereNot(conditions);\n}\n\nexport class WhereNot extends WhereOp {\n  constructor(protected conditions: AnyConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineNot(params, this.conditions, precedence, name);\n  }\n}\n","import { Dictionary, Many } from 'lodash';\nimport { NodePattern } from './node-pattern';\nimport { RelationDirection, RelationPattern } from './relation-pattern';\nimport { PathLength } from '../utils';\n\nexport { Create } from './create';\nexport { NodePattern } from './node-pattern';\nexport { With } from './with';\nexport { Unwind } from './unwind';\nexport { Delete } from './delete';\nexport { Set } from './set';\nexport { RelationPattern } from './relation-pattern';\nexport { Match } from './match';\nexport { Remove } from './remove';\nexport { Return } from './return';\nexport { Skip } from './skip';\nexport { Limit } from './limit';\nexport { Where } from './where';\nexport { Raw } from './raw';\nexport { OrderBy } from './order-by';\nexport { Merge } from './merge';\nexport { OnMatch } from './on-match';\nexport { OnCreate } from './on-create';\nexport { and, or, xor, not, operators } from './where-operators';\nexport {\n  equals,\n  greaterThan,\n  greaterEqualTo,\n  lessThan,\n  lessEqualTo,\n  startsWith,\n  endsWith,\n  contains,\n  inArray,\n  hasLabel,\n  exists,\n  between,\n  isNull,\n  regexp,\n  comparisions,\n} from './where-comparators';\n\n/**\n * Creates a node pattern like `(parent:Person { name: 'Gwenn' })`.\n *\n * All of the arguments are optional and most of the time you can supply only\n * the ones you want, assuming you keep the order the same of course.\n *\n * Use the following signatures as a reference:\n *\n * ```typescript\n * node(conditions: Dictionary<any>)\n * node(labels: string[], conditions?: Dictionary<any>)\n * node(name: string, conditions?: Dictionary<any>)\n * node(name: string, labels?: string | string[], conditions?: Dictionary<any>)\n * ```\n * *Note that labels must be an array when it is the first argument.*\n *\n *\n *\n * Some examples\n *\n * ```typescript\n * node()\n * // ()\n *\n * node('parent')\n * // (parent)\n *\n * node('parent', 'Person')\n * // (parent:Person)\n *\n * node([ 'Person' ])\n * // (:Person)\n *\n * node('parent', [ 'Person', 'Adult' ])\n * // (parent:Person:Adult)\n *\n * node({ name: 'Gwenn' })\n * // ({ name: 'Gwenn' })\n *\n * node('parent', { name: 'Gwenn' })\n * // (parent { name: 'Gwenn' })\n *\n * node([ 'Person' ], { name: 'Gwenn' })\n * // (:Person { name: 'Gwenn' })\n *\n * node('parent', 'Person', { name: 'Gwenn' })\n * // (parent:Person { name: 'Gwenn' })\n * ```\n *\n * For more details on node patterns see the cypher\n * [docs]{@link\n * https://neo4j.com/docs/developer-manual/current/cypher/syntax/patterns/#cypher-pattern-node}\n *\n * @param {_.Many<string> | _.Dictionary<any>} name\n * @param {_.Many<string> | _.Dictionary<any>} labels\n * @param {_.Dictionary<any>} conditions A dictionary of conditions to attach\n * to the node. These are stored as parameters so there is no need to worry\n * about escaping.\n * @returns {NodePattern} An object representing the node pattern.\n */\nexport function node(\n  name?: Many<string> | Dictionary<any>,\n  labels?: Many<string> | Dictionary<any>,\n  conditions?: Dictionary<any>,\n) {\n  return new NodePattern(name, labels, conditions);\n}\n\n// Need to disable line length because there is a long link in the documentation\n/* tslint:disable:max-line-length */\n/**\n * Creates a relation pattern like `-[rel:FriendsWith { active: true }]->`.\n *\n * The only required argument is direction. All other arguments are optional and all combinations of\n * them are valid. The only exception is that when labels is the first argument after direction, it\n * must be an array, otherwise it will be interpreted as the relation name.\n *\n * Some examples\n *\n * ```typescript\n * relation('either')\n * //  --\n *\n * relation('out', 'rel')\n * //  -[rel]->\n *\n * relation('out', 'rel', 'FriendsWith')\n * //  -[rel:FriendsWith]->\n *\n * relation('in', [ 'FriendsWith', 'RelatedTo' ])\n * // <-[:FriendsWith|RelatedTo]-\n * // Note that this will match a relation with either the FriendsWith label or\n * // the RelatedTo label. You cannot use this syntax when creating relations.\n *\n * relation('in', [4, 10])\n * // <-[*4..10]-\n *\n * relation('in', { active: true })\n * // <-[{ active: true }]\n *\n * relation('in', 'rel', { active: true })\n * // <-[rel { active: true }]-\n *\n * relation('either', [ 'FriendsWith' ], { active: true })\n * //  -[:FriendsWith { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, 3)\n * //  -[rel:FriendsWith*3 { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, [ 3 ])\n * //  -[rel:FriendsWith*3.. { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, [ 3, 5 ])\n * //  -[rel:FriendsWith*3..5 { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, '*')\n * //  -[rel:FriendsWith* { active: true }]-\n * ```\n *\n * For more details on relation patterns see the cypher\n * [docs]{@link\n * https://neo4j.com/docs/developer-manual/current/cypher/syntax/patterns/#cypher-pattern-relationship}.\n *\n * @param dir Direction of the relation. `in` means to the left, `out` means to\n * the right and `either` means no direction.\n * @param {_.Many<string> | _.Dictionary<any>} name\n * @param {_.Many<string> | _.Dictionary<any>} labels\n * @param {_.Dictionary<any>} conditions\n * @param length Length of the relation for flexible length paths. Can be the\n * string `'*'` to represent any length, a single number `3` to represent the\n * maximum length of the path, or an array of two numbers which represent the\n * minimum and maximum length of the path. When passing an array, the second\n * number is optional, see the examples above.\n * @returns {RelationPattern} An object representing the relation pattern.\n */\n/* tslint:disable:max-line-length */\nexport function relation(\n  dir: RelationDirection,\n  name?: Many<string> | Dictionary<any> | PathLength,\n  labels?: Many<string> | Dictionary<any> | PathLength,\n  conditions?: Dictionary<any> | PathLength,\n  length?: PathLength,\n) {\n  return new RelationPattern(dir, name, labels, conditions, length);\n}\n","import { Clause } from '../clause';\n\nexport class Union extends Clause {\n  constructor(public all: boolean = false) {\n    super();\n  }\n\n  build() {\n    return `UNION${this.all ? ' ALL' : ''}`;\n  }\n}\n","import { Dictionary, Many, assign } from 'lodash';\nimport {\n  Limit, Match, NodePattern, Skip, Where, Set, Create,\n  Return, With, Unwind, Delete, Raw, OrderBy, Merge, OnCreate, OnMatch,\n  Remove,\n} from './clauses';\nimport { CreateOptions } from './clauses/create';\nimport { DeleteOptions } from './clauses/delete';\nimport { MatchOptions } from './clauses/match';\nimport { Direction, OrderConstraint, OrderConstraints } from './clauses/order-by';\nimport { PatternCollection } from './clauses/pattern-clause';\nimport { SetOptions, SetProperties } from './clauses/set';\nimport { Term } from './clauses/term-list-clause';\nimport { AnyConditions } from './clauses/where-utils';\nimport { Clause } from './clause';\nimport { RemoveProperties } from './clauses/remove';\nimport { Union } from './clauses/union';\nimport { ReturnOptions } from './clauses/return';\n\n/**\n * @internal\n */\nexport interface WrapperClause {\n  new (clause: Set): Clause;\n}\n\n/**\n * @internal\n */\nexport class SetBlock<Q> {\n  constructor(protected chain: (clause: Clause) => Q, protected wrapper?: WrapperClause) { }\n\n  /**\n   * Adds a [set]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause to the query.\n   *\n   * `set` lets you updates a nodes labels and properties in one clause. Most of\n   * the time it will be easier to use one of the variants such as `setLabels`,\n   * `setValues` or `setVariables`.\n   *\n   * This function accepts three different kind of properties, each of which is\n   * described in more detail in the variants.\n   *\n   * ```\n   * query.set({\n   *   labels: {\n   *     sale: 'Active',\n   *   },\n   *   variables: {\n   *     sale: {\n   *       activatedAt: 'timestamp()',\n   *     },\n   *   },\n   *   values: {\n   *     sale: {\n   *       activatedBy: user.id,\n   *     },\n   *   },\n   * })\n   * // SET sale:Active, sale.activatedAt = timestamp(), sale.activatedBy = $userId\n   * ```\n   *\n   * `set` also accepts an options object which currently only contains a\n   * single setting: `override`. Override controls whether the `=` or `+=`\n   * operator is used in the set clause. `true` causes the existing object to be\n   * cleared and replaced by the new object. `false` on the other hand will\n   * merge the existing and new objects together, with new properties replacing\n   * the ones on the existing object.\n   * The default value of override is a little inconsistent and it will be\n   * improved in the next major version. If you don't pass any settings object,\n   * override will default to `true`. If you pass an options object without an\n   * `override` key, override will be `false`. In future versions, override will\n   * always default to `false` to be more consistent with `setVariables` and\n   * `setValues`.\n   *\n   * @param {SetProperties} properties\n   * @param {SetOptions} options\n   * @returns {Q}\n   */\n  set(properties: SetProperties, options?: SetOptions) {\n    return this.chain(this.wrap(new Set(properties, options)));\n  }\n\n  /**\n   * Adds labels to a node using a [set]{@link\n    * https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause.\n   *\n   * ```\n   * query.setLabels({\n   *   sale: 'Active',\n   * })\n   * // SET sale:Active\n   * ```\n   *\n   * `setLabels` accepts a dictionary where the keys are nodes to be updated\n   * and the value is a single label or an array of labels to add to the node.\n   *\n   * @param {_.Dictionary<_.Many<string>>} labels\n   * @returns {Q}\n   */\n  setLabels(labels: Dictionary<Many<string>>) {\n    return this.chain(this.wrap(new Set({ labels })));\n  }\n\n  /**\n   * Updates a node from parameters using a [set]{@link\n    * https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause. This function treats all values as parameters which is different to\n   * `setVariables` which assumes values are cypher variables.\n   *\n   * ```\n   * query.setValues({\n   *   'sale.activatedBy': user.id,\n   * })\n   * // SET sale.activatedBy += $userId\n   * ```\n   *\n   * `setValues` accepts a dictionary where the keys are nodes or property names\n   * to be updated.\n   *\n   * To use the `+=` operator to merge properties of a node, you can pass\n   * `true` to the merge option.\n   * ```\n   * query.setValues({\n   *   'sale': { active: true },\n   * }, true)\n   * // SET sale += $sale\n   * ```\n   */\n  setValues(values: Dictionary<any>, merge?: boolean) {\n    return this.chain(this.wrap(new Set({ values }, { merge })));\n  }\n\n  /**\n   * Updates a node from a variable that was previously declared in the query\n   * using a [set]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause. This function only accepts strings as its values which are not\n   * escaped in any way so beware. If you want to store some user supplied\n   * information in the database, `setValues` is the function you want.\n   *\n   * ```\n   * query.setVariables({\n   *   'sale.activatedAt': 'timestamp()',\n   * })\n   * // SET sale.activatedAt = timestamp()\n   * ```\n   * Note how values are inserted into the query, as is.\n   *\n   * To use the `+=` operator to merge properties of a node, you can pass\n   * `true` to the merge option.\n   * ```\n   * query.setVariables({\n   *   'sale': 'newSaleDetails'\n   * }, true)\n   * // SET sale += newSaleDetails\n   * ```\n   */\n  setVariables(variables: Dictionary<string | Dictionary<string>>, merge?: boolean) {\n    return this.chain(this.wrap(new Set({ variables }, { merge })));\n  }\n\n  private wrap(clause: Set): Clause {\n    return this.wrapper ? new this.wrapper(clause) : clause;\n  }\n}\n\n/**\n * Root class for all query chains, namely the {@link Connection} and\n * {@link Query} classes.\n * @internal\n */\nexport abstract class Builder<Q> extends SetBlock<Q> {\n  protected constructor() {\n    super(c => this.continueChainClause(c));\n  }\n\n  /**\n   * Used to add an `ON CREATE` clause to the query. Any following query will be prefixed with\n   * `ON CREATE`.\n   *\n   * Example:\n   * ```javascript\n   * query.onCreate.setLabels({ node: 'Active' });\n   * // ON CREATE SET node:Active\n\n   * query.onCreate.setVariables({ 'node.createdAt': 'timestamp()' });\n   * // ON CREATE SET node.createdAt = timestamp()\n   * ````\n   *\n   * The only methods that are available after `onCreate` are the set family of clauses.\n   */\n  onCreate = new SetBlock<Q>(this.continueChainClause.bind(this), OnCreate);\n\n  /**\n   * Used to add an `ON MATCH` clause to the query. Any following query will be prefixed with\n   * `ON MATCH`.\n   *\n   * Example:\n   * ```javascript\n   * query.onMatch.setLabels({ node: 'Active' });\n   * // ON MATCH SET node:Active\n\n   * query.onMatch.setVariables({ 'node.updatedAt': 'timestamp()' });\n   * // ON MATCH SET node.createdAt = timestamp()\n   * ````\n   *\n   * The only methods that are available after `onMatch` are the set family of clauses.\n   */\n  onMatch = new SetBlock<Q>(this.continueChainClause.bind(this), OnMatch);\n\n  /**\n   * Adds a clause to the current chain and returns something that can be\n   * chained with more clauses.\n   * @param {Clause} clause\n   * @returns {Q}\n   */\n  protected abstract continueChainClause(clause: Clause): Q;\n\n  /**\n   * Adds a [create]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/create}\n   * clause to the query.\n   *\n   * Create accepts a single pattern, a list of patterns or a list of a list of\n   * patterns. Each pattern represents a single part of a cypher pattern. For\n   * example: `(people:Person { age: 30 })` would be a node pattern and\n   * `-[:FriendsWith]->` would be a relationship pattern.\n   *\n   * If an array of patterns is provided, they are joined together to form a\n   * composite pattern. For example:\n   * ```javascript\n   * query.create([\n   *   node('people', 'Person', { age: 30 }),\n   *   relation('out', '', 'FriendsWith'),\n   *   node('friend', 'Friend'),\n   * ])\n   * ```\n   *\n   * Would equate to the cypher pattern\n   * ```\n   * CREATE (people:Person { age: 30 })-[:FriendsWith]->(friend:Friend)\n   * ```\n   *\n   * The create method also accepts a `unique` option which will cause a `CREATE UNIQUE` clause to\n   * be emitted instead.\n   * ```javascript\n   * query.create([node('people', 'Person', { age: 30 })], { unique: true });\n   * // CREATE UNIQUE (people:Person { age: 30 })\n   * ```\n   */\n  create(patterns: PatternCollection, options?: CreateOptions) {\n    return this.continueChainClause(new Create(patterns, options));\n  }\n\n  /**\n   * Shorthand for `create(patterns, { unique: true })`\n   */\n  createUnique(patterns: PatternCollection) {\n    return this.create(patterns, { unique: true });\n  }\n\n  /**\n   * Shorthand for `create(node(name, labels, conditions), options)`. For more details\n   * the arguments see @{link node}.\n   */\n  createNode(\n    name: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n    options?: CreateOptions,\n  ) {\n    const clause = new Create(new NodePattern(name, labels, conditions), options);\n    return this.continueChainClause(clause);\n  }\n\n  /**\n   * Shorthand for `createNode(name, labels, conditions, { unique: true })`\n   */\n  createUniqueNode(\n    name: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    return this.createNode(name, labels, conditions, { unique: true });\n  }\n\n  /**\n   * Adds a [delete]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/delete}\n   * clause to the query.\n   *\n   * Delete accepts a single string or an array of them and all of them are\n   * joined together with commas. *Note that these strings are not escaped or\n   * passed to Neo4j using parameters, therefore you should not pass user\n   * input into this clause without escaping it first*.\n   *\n   * You can set `detach: true` in the options to make it a `DETACH DELETE`\n   * clause.\n   *\n   * @param {_.Many<string>} terms\n   * @param {DeleteOptions} options\n   * @returns {Q}\n   */\n  delete(terms: Many<string>, options?: DeleteOptions) {\n    return this.continueChainClause(new Delete(terms, options));\n  }\n\n  /**\n   * Shorthand for `delete(terms, { detach: true })`.\n   *\n   * @param {_.Many<string>} terms\n   * @param {DeleteOptions} options\n   * @returns {Q}\n   */\n  detachDelete(terms: Many<string>, options: DeleteOptions = {}) {\n    return this.continueChainClause(new Delete(terms, assign(options, {\n      detach: true,\n    })));\n  }\n\n  /**\n   * Adds a [limit]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/limit}\n   * clause to the query.\n   *\n   * @param {string | number} amount\n   * @returns {Q}\n   */\n  limit(amount: number) {\n    return this.continueChainClause(new Limit(amount));\n  }\n\n  /**\n   * Adds a [match]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/match}\n   * clause to the query.\n   *\n   * Match accepts a single pattern, a list of patterns or a list of a list of\n   * patterns. Each pattern represents a single part of a cypher pattern. For\n   * example: `(people:Person { age: 30 })` would be a node pattern and\n   * `-[:FriendsWith]->` would be a relationship pattern.\n   *\n   * If an array of patterns is provided, they are joined together to form a\n   * composite pattern. For example:\n   * ```javascript\n   * query.match([\n   *   node('people', 'Person', { age: 30 }),\n   *   relation('out', '', 'FriendsWith'),\n   *   node('friends'),\n   * ])\n   * ```\n   *\n   * Would equate to the cypher pattern\n   * ```\n   * MATCH (people:Person { age: 30 })-[:FriendsWith]->(friends)\n   * ```\n   *\n   * If an array of an array of patterns is provided each array is joined\n   * together like above, and then each composite pattern is joined with a comma\n   * to allow matching of multiple distinct patterns. Note: matching many\n   * distinct patterns will produce a cross product of the results as noted in\n   * the [cypher docs]{@link\n   * https://neo4j.com/developer/kb/cross-product-cypher-queries-will-not-perform-well/}.\n   *\n   * You can also provide `optional: true` in the options to create and\n   * `OPTIONAL MATCH` clause.\n   *\n   * @param {PatternCollection} patterns List of patterns to be matched.\n   * @param {MatchOptions} options\n   * @returns {Q}\n   */\n  match(patterns: PatternCollection, options?: MatchOptions) {\n    return this.continueChainClause(new Match(patterns, options));\n  }\n\n  /**\n   * Shorthand for `match(node(name, labels, conditions))`. For more details on\n   * the arguments see {@link node}.\n   *\n   * @param {_.Many<string> | _.Dictionary<any>} name\n   * @param {_.Many<string> | _.Dictionary<any>} labels\n   * @param {_.Dictionary<any>} conditions\n   * @returns {Q}\n   */\n  matchNode(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    const clause = new Match(new NodePattern(name, labels, conditions));\n    return this.continueChainClause(clause);\n  }\n\n  /**\n   * Shorthand for `match(patterns, { optional: true })`.\n   *\n   * @param {PatternCollection} patterns\n   * @param {MatchOptions} options\n   * @returns {Q}\n   */\n  optionalMatch(patterns: PatternCollection, options: MatchOptions = {}) {\n    return this.continueChainClause(new Match(patterns, assign(options, {\n      optional: true,\n    })));\n  }\n\n  /**\n   * Adds a [merge]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/merge/}\n   * clause to the query. It accepts the same parameters as `match` and `create` so refer to them\n   * for more information.\n   *\n   * ```javascript\n   * query.merge([\n   *   node('user', 'User', { id: 1 }),\n   *   relation('out', 'rel', 'OwnsProject'),\n   *   node('project', 'Project', { id: 20 }),\n   * ])\n   * .onMatch.setVariables({ 'rel.updatedAt': `timestamp` });\n   * // MERGE (user:User { id: 1 })-[rel:OwnsProject]->(project:Project { id: 20 })\n   * // ON MATCH SET rel.updatedAt = timestamp()\n   * ```\n   */\n  merge(patterns: PatternCollection) {\n    return this.continueChainClause(new Merge(patterns));\n  }\n\n  /**\n   * Adds an [order by]{@link\n   * https://neo4j.com/docs/developer-manual/current/cypher/clauses/order-by}\n   * to the query.\n   *\n   * Pass a single string or an array of strings to order by.\n   * ```javascript\n   * query.orderBy([\n   *   'name',\n   *   'occupation',\n   * ])\n   * // ORDER BY name, occupation\n   * ```\n   *\n   * You can control the sort direction by adding a direction to each property.\n   * ```javascript\n   * query.orderBy([\n   *   ['name', 'DESC'],\n   *   'occupation', // Same as ['occupation', 'ASC']\n   * ])\n   * // ORDER BY name DESC, occupation\n   * ```\n   *\n   * The second parameter is the default search direction for all properties that\n   * don't have a direction specified. So the above query could instead be\n   * written as:\n   * ```javascript\n   * query.orderBy([\n   *   'name',\n   *   ['occupation', 'ASC']\n   * ], 'DESC')\n   * // ORDER BY name DESC, occupation\n   * ```\n   *\n   * It is also acceptable to pass an object where each key is the\n   * property and the value is a direction. Eg:\n   * ```javascript\n   * query.orderBy({\n   *   name: 'DESC',\n   *   occupation: 'ASC',\n   * })\n   * ```\n   * However, the underlying iteration order is not always guaranteed and\n   * it may cause subtle bugs in your code. It is still accepted but it\n   * is recommended that you use the array syntax above.\n   *\n   * Valid values for directions are `DESC`, `DESCENDING`, `ASC`, `ASCENDING`.\n   * `true` and `false` are also accepted (`true` being the same as `DESC` and\n   * `false` the same as `ASC`), however they should be avoided as they are\n   * quite ambiguous. Directions always default to `ASC` as it does in cypher.\n   *\n   * @param {_.Many<string> | OrderConstraints} fields\n   * @param {Direction} dir\n   * @returns {Q}\n   */\n  orderBy(fields: string | (string | OrderConstraint)[] | OrderConstraints, dir?: Direction) {\n    return this.continueChainClause(new OrderBy(fields, dir));\n  }\n\n  /**\n   * Adds a clause to the query as is. You can also provide an object of params\n   * as well.\n   *\n   * ```javascript\n   * query.raw('MATCH (:Event { date: $date }', { date: '2017-01-01' })\n   * ```\n   *\n   * `raw` can also be used as a template tag\n   *\n   * ```javascript\n   * query.matchNode('event', 'Event', { id: 1 })\n   *  .raw`SET event.finishedAt = ${Date.now()}`\n   * ```\n   *\n   * But note that using template parameters where they are not supported in a query will produce\n   * an malformed query.\n   *\n   * ```javascript\n   * query.raw`SET node.${property} = 'value'`\n   * // Invalid query:\n   * // SET node.$param1 = 'value'\n   * ```\n   *\n   * @param {string} clause\n   * @param args\n   * @returns {Q}\n   */\n  raw(clause: string | TemplateStringsArray, ...args: any[]) {\n    return this.continueChainClause(new Raw(clause, ...args));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass objects containing the list of properties and labels to remove from a node. Each key in an\n   * object is the name of a node and the values are the names of the labels and properties to\n   * remove. The values of each object can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   labels: {\n   *     coupon: 'Active',\n   *   },\n   *   properties: {\n   *     customer: ['inactive', 'new'],\n   *   },\n   * });\n   * // REMOVE coupon:Active, customer.inactive, customer.new\n   * ```\n   *\n   * Both labels and properties objects are optional, but you must provide at least one of them for\n   * the query to be syntatically valid.\n   * ```\n   * query.remove({\n   *\n   * });\n   * // Invalid query:\n   * // REMOVE\n   * ```\n   *\n   * If you only need to remove labels *or* properties, you may find `removeProperties` or\n   * `removeLabels` more convenient.\n   */\n  remove(properties: RemoveProperties) {\n    return this.continueChainClause(new Remove(properties));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass an object containing the list of properties to remove from a node. Each key in the\n   * object is the name of a node and the values are the names of the properties to remove. The\n   * values can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   customer: ['inactive', 'new'],\n   *   coupon: 'available',\n   * });\n   * // REMOVE customer.inactive, customer.new, coupon.available\n   * ```\n   */\n  removeProperties(properties: Dictionary<Many<string>>) {\n    return this.continueChainClause(new Remove({ properties }));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass an object containing the list of labels to remove from a node. Each key in the\n   * object is the name of a node and the values are the names of the labels to remove. The\n   * values can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   customer: ['Inactive', 'New'],\n   *   coupon: 'Available',\n   * });\n   * // REMOVE customer:Inactive, customer:New, coupon:Available\n   * ```\n   */\n  removeLabels(labels: Dictionary<Many<string>>) {\n    return this.continueChainClause(new Remove({ labels }));\n  }\n\n  /**\n   * Adds a [return]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/return}\n   * clause to the query.\n   *\n   * There are many different ways to pass arguments to `return` so each is\n   * documented in turn below.\n   *\n   * A single string:\n   * ```javascript\n   * query.return('people')\n   * // RETURN people\n   * ```\n   *\n   * An array of strings to return multiple variables:\n   * ```javascript\n   * query.return([ 'people', 'pets' ])\n   * // RETURN people, pets\n   * ```\n   *\n   * A single object to rename variables:\n   * ```javascript\n   * query.return({ people: 'employees' })\n   * // RETURN people AS employees\n   * ```\n   *\n   * A single object with an array for each value:\n   * ```javascript\n   * query.return({\n   *   people: [ 'name', 'age' ],\n   *   pets: [ 'name', 'breed' ],\n   * })\n   * // RETURN people.name, people.age, pets.name, pets.breed\n   * ```\n   * This gives you a shortcut to specifying many node properties. You can also\n   * rename each property by adding an object inside the array or by providing\n   * an object as the value:\n   * ```javascript\n   * query.return({\n   *   people: [{ name: 'personName' }, 'age' ],\n   * })\n   * // RETURN people.name as personName, people.age\n   * ```\n   * or\n   * ```javascript\n   * query.return({\n   *   people: {\n   *     name: 'personName',\n   *     age: 'personAge',\n   *   },\n   * })\n   * // RETURN people.name as personName, people.age as personAge\n   * ```\n   *\n   * You can also pass an array of any of the above methods.\n   *\n   * The return method also accepts a `distinct` option which will cause a `RETURN DISTINCT` clause\n   * to be emitted instead.\n   * ```javascript\n   * query.return('people', { distinct: true })\n   * // RETURN DISTINCT people\n   * ```\n   */\n  return(terms: Many<Term>, options?: ReturnOptions) {\n    return this.continueChainClause(new Return(terms, options));\n  }\n\n  /**\n   * Shorthand for `return(terms, { distinct: true });\n   */\n  returnDistinct(terms: Many<Term>) {\n    return this.return(terms, { distinct: true });\n  }\n\n  /**\n   * Adds a [skip]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/skip}\n   * clause to the query.\n   *\n   * @param {string | number} amount\n   * @returns {Q}\n   */\n  skip(amount: number) {\n    return this.continueChainClause(new Skip(amount));\n  }\n\n  /**\n   * Add a [union]{@link https://neo4j.com/docs/cypher-manual/current/clauses/union/} clause to the\n   * query.\n   *\n   * ```javascript\n   * query.matchNode('people', 'People')\n   *   .return({ 'people.name': 'name' })\n   *   .union()\n   *   .matchNode('departments', 'Department')\n   *   .return({ 'departments.name': 'name' });\n   * // MATCH (people:People)\n   * // RETURN people.name AS name\n   * // UNION\n   * // MATCH (departments:Department)\n   * // RETURN departments.name AS name\n   * ```\n   */\n  union(all?: boolean) {\n    return this.continueChainClause(new Union(all));\n  }\n\n  /**\n   * Add a [union all]{@link https://neo4j.com/docs/cypher-manual/current/clauses/union/} clause to\n   * the query. Just shorthand for `union(true)`.\n   *\n   * ```javascript\n   * query.matchNode('people', 'People')\n   *   .return({ 'people.name': 'name' })\n   *   .unionAll()\n   *   .matchNode('departments', 'Department')\n   *   .return({ 'departments.name': 'name' });\n   * // MATCH (people:People)\n   * // RETURN people.name AS name\n   * // UNION ALL\n   * // MATCH (departments:Department)\n   * // RETURN departments.name AS name\n   * ```\n   */\n  unionAll() {\n    return this.continueChainClause(new Union(true));\n  }\n\n  /**\n   * Adds an [unwind]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/unwind}\n   * clause to the query.\n   *\n   * @param {any[]} list Any kind of array to unwind in the query\n   * @param {string} name Name of the variable to use in the unwinding\n   * @returns {Q}\n   */\n  unwind(list: any[], name: string) {\n    return this.continueChainClause(new Unwind(list, name));\n  }\n\n  /**\n   * Adds a [where]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/where}\n   * clause to the query.\n   *\n   * `where` is probably the most complex clause in this package because of the flexible ways to\n   * combine conditions. A handy rule of thumb is when you see an array it becomes an `OR` and when\n   * you see a dictionary, it becomes an `AND`. The many different ways of specifying your\n   * constraints are listed below.\n   *\n   * As a simple object, the comparison of each property is just `AND`ed together.\n   * ```javascript\n   * query.where({\n   *   name: 'Alan',\n   *   age: 54,\n   * })\n   * // WHERE name = 'Alan' AND age = 54\n   * ```\n   *\n   * You can wrap your constraints in a top level dictionary in which case the key of the outer\n   * dictionary will be considered the name of the node.\n   * ```javascript\n   * query.where({\n   *   person: {\n   *     name: 'Alan',\n   *     age: 54,\n   *   },\n   * })\n   * // WHERE person.name = 'Alan' AND person.age = 54\n   * ```\n   *\n   * Using an array, you can generate `OR`ed conditions.\n   * ```javascript\n   * query.where([\n   *   { name: 'Alan' },\n   *   { age: 54 },\n   * ])\n   * // WHERE name = 'Alan' OR age = 54\n   * ```\n   *\n   * Arrays can be placed at many levels in the conditions.\n   * ```javascript\n   * query.where({\n   *   name: [ 'Alan', 'Steve', 'Bob' ],\n   * })\n   * // WHERE name = 'Alan' OR name = 'Steve' OR name = 'Bob'\n   *\n   * query.where({\n   *   person: [\n   *     { name: 'Alan' },\n   *     { age: 54 },\n   *   ],\n   * })\n   * // WHERE person.name = 'Alan' OR person.age = 54\n   *\n   * query.where([\n   *   { employee: { name: 'Alan' } },\n   *   { department: { code: 765 } },\n   * })\n   * // WHERE employee.name = 'Alan' OR department.code = 765\n   * ```\n   *\n   * For more complex comparisons, you can use the comparator functions such as:\n   * ```javascript\n   * query.where({\n   *   age: greaterThan(30),\n   * })\n   * // WHERE age > 30\n   * ```\n   *\n   * The full list of comparators currently supported are:\n   *  - [between]{@link http://jamesfer.me/cypher-query-builder/globals.html#between}\n   *  - [contains]{@link http://jamesfer.me/cypher-query-builder/globals.html#contains}\n   *  - [endsWith]{@link http://jamesfer.me/cypher-query-builder/globals.html#endswith}\n   *  - [equals]{@link http://jamesfer.me/cypher-query-builder/globals.html#equals}\n   *  - [exists]{@link http://jamesfer.me/cypher-query-builder/globals.html#exists}\n   *  - [greaterEqualTo]{@link http://jamesfer.me/cypher-query-builder/globals.html#greaterequalto}\n   *  - [greaterThan]{@link http://jamesfer.me/cypher-query-builder/globals.html#greaterthan}\n   *  - [hasLabel]{@link http://jamesfer.me/cypher-query-builder/globals.html#haslabel}\n   *  - [inArray]{@link http://jamesfer.me/cypher-query-builder/globals.html#inarray}\n   *  - [isNull]{@link http://jamesfer.me/cypher-query-builder/globals.html#isnull}\n   *  - [lessEqualTo]{@link http://jamesfer.me/cypher-query-builder/globals.html#lessequalto}\n   *  - [lessThan]{@link http://jamesfer.me/cypher-query-builder/globals.html#lessthan}\n   *  - [regexp]{@link http://jamesfer.me/cypher-query-builder/globals.html#regexp}\n   *  - [startsWith]{@link http://jamesfer.me/cypher-query-builder/globals.html#startswith}\n   *\n   * You can import the comparisons one at a time or all at once.\n   * ```javascript\n   * import { greaterThan, regexp } from 'cypher-query-builder';\n   * // or\n   * import { comparisons } form 'cypher-query-builder';\n   * ```\n   *\n   * For convenience you can also pass a Javascript RegExp object as a value,\n   * which will then be converted into a string before it is passed to cypher.\n   * *However*, beware that the cypher regexp syntax is inherited from\n   * [java]{@link\n    * https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html},\n   * and may have slight differences to the Javascript syntax. If you would\n   * prefer, you can use the `regexp` comparator and use strings instead of\n   * RegExp objects. For example, Javascript RegExp flags will not be\n   * preserved when sent to cypher.\n   * ```javascript\n   * query.where({\n   *   name: /[A-Z].*son/,\n   * })\n   * // WHERE age =~ '[A-Z].*son'\n   * ```\n   *\n   * All the binary operators including `xor` and `not` are available as well and can also be\n   * imported individually or all at once.\n   * ```javascript\n   * import { xor, and } from 'cypher-query-builder';\n   * // or\n   * import { operators } form 'cypher-query-builder';\n   * ```\n   *\n   * The operators can be placed at any level of the query.\n   * ```javascript\n   * query.where({\n   *   age: xor([lessThan(12), greaterThan(65)])\n   * })\n   * // WHERE age < 12 XOR age > 65\n   * ```\n   *\n   * @param {AnyConditions} conditions\n   * @returns {Q}\n   */\n  where(conditions: AnyConditions) {\n    return this.continueChainClause(new Where(conditions));\n  }\n\n  /**\n   * Adds a [with]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/with}\n   * clause to the query.\n   *\n   * There are many different ways to pass arguments to `with` so each is\n   * documented in turn below.\n   *\n   * A single string:\n   * ```javascript\n   * query.with('people')\n   * // WITH people\n   * ```\n   *\n   * An array of strings to return multiple variables:\n   * ```javascript\n   * query.with([ 'people', 'pets' ])\n   * // WITH people, pets\n   * ```\n   *\n   * A single object to rename variables:\n   * ```javascript\n   * query.with({ people: 'employees' })\n   * // WITH people AS employees\n   * ```\n   *\n   * A single object with an array for each value:\n   * ```javascript\n   * query.with({\n   *   people: [ 'name', 'age' ],\n   *   pets: [ 'name', 'breed' ],\n   * })\n   * // WITH people.name, people.age, pets.name, pets.breed\n   * ```\n   * This gives you a shortcut to specifying many node properties. You can also\n   * rename each property by adding an object inside the array or by providing\n   * an object as the value:\n   * ```javascript\n   * query.with({\n   *   people: [{ name: 'personName' }, 'age' ],\n   * })\n   * // WITH people.name as personName, people.age\n   * ```\n   * or\n   * ```javascript\n   * query.with({\n   *   people: {\n   *     name: 'personName',\n   *     age: 'personAge',\n   *   },\n   * })\n   * // WITH people.name as personName, people.age as personAge\n   * ```\n   *\n   * You can also pass an array of any of the above methods.\n   *\n   * @param {_.Many<Term>} terms\n   * @returns {Q}\n   */\n  with(terms: Many<Term>) {\n    return this.continueChainClause(new With(terms));\n  }\n}\n","import neo4j from 'neo4j-driver/lib/browser/neo4j-web';\nimport { Dictionary, map, mapValues, isArray } from 'lodash';\nimport { Record, Integer } from 'neo4j-driver/types/v1';\n\nexport type NeoValue = string | boolean | null | number | Integer;\nexport interface NeoNode {\n  identity: Integer;\n  labels: string[];\n  properties: Dictionary<NeoValue>;\n}\nexport interface NeoRelation {\n  identity: Integer;\n  start: Integer;\n  end: Integer;\n  type: string;\n  properties: Dictionary<NeoValue>;\n}\n\nexport type PlainValue = string | boolean | null | number;\nexport type PlainArray = string[] | boolean[] | number[];\nexport interface Node<P = Dictionary<PlainValue | PlainArray>> {\n  identity: string;\n  labels: string[];\n  properties: P;\n}\nexport interface Relation<P = Dictionary<PlainValue | PlainArray>> {\n  identity: string;\n  start: string;\n  end: string;\n  label: string;\n  properties: P;\n}\n\nexport class Transformer {\n  transformRecords<T= any>(records: Record[]): Dictionary<T>[] {\n    return map(records, rec => this.transformRecord(rec));\n  }\n\n  transformRecord<T = any>(record: Record): Dictionary<T> {\n    return mapValues(record.toObject() as any, node => this.transformValue(node));\n  }\n\n  private transformValue(value: any): any {\n    if (this.isPlainValue(value)) {\n      return value;\n    }\n    if (isArray(value)) {\n      return map(value, v => this.transformValue(v));\n    }\n    if (neo4j.isInt(value)) {\n      return this.convertInteger(value);\n    }\n    if (this.isNode(value)) {\n      return this.transformNode(value);\n    }\n    if (this.isRelation(value)) {\n      return this.transformRelation(value);\n    }\n    if (typeof value === 'object') {\n      return mapValues(value, v => this.transformValue(v));\n    }\n    return null;\n  }\n\n  private isPlainValue(value: any): value is PlainValue {\n    const type = typeof value;\n    return value == null || type === 'string' || type === 'boolean' || type === 'number';\n  }\n\n  private isNode(node: any): node is NeoNode {\n    return node !== null\n      && typeof node === 'object'\n      && !isArray(node)\n      && node.identity\n      && node.labels\n      && node.properties;\n  }\n\n  private transformNode(node: NeoNode): Node {\n    return {\n      identity: neo4j.integer.toString(node.identity),\n      labels: node.labels,\n      properties: mapValues(node.properties, this.transformValue.bind(this)),\n    };\n  }\n\n  private isRelation(rel: Dictionary<any>): rel is NeoRelation {\n    return rel.identity && rel.type && rel.properties && rel.start && rel.end;\n  }\n\n  private transformRelation(rel: NeoRelation): Relation {\n    return {\n      identity: neo4j.integer.toString(rel.identity),\n      start: neo4j.integer.toString(rel.start),\n      end: neo4j.integer.toString(rel.end),\n      label: rel.type,\n      properties: mapValues(rel.properties, this.transformValue.bind(this)),\n    };\n  }\n\n  private convertInteger(num: Integer) {\n    if (neo4j.integer.inSafeRange(num)) {\n      return neo4j.integer.toNumber(num);\n    }\n    return neo4j.integer.toString(num);\n  }\n}\n","import { map } from 'lodash';\nimport { Clause } from './clause';\n\nexport class ClauseCollection extends Clause {\n  protected clauses: Clause[] = [];\n\n  /**\n   * Returns all clauses in this collection.\n   * @returns {Clause[]}\n   */\n  getClauses(): Clause[] {\n    return this.clauses;\n  }\n\n  /**\n   * Adds a clause to the child list.\n   * @param {Clause} clause\n   */\n  addClause(clause: Clause) {\n    clause.useParameterBag(this.parameterBag);\n    this.clauses.push(clause);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  build() {\n    return `${map(this.clauses, s => s.build()).join('\\n')};`;\n  }\n}\n","// tslint:disable-next-line import-name\nimport AnyPromise from 'any-promise';\n// tslint:disable-next-line import-name\nimport Observable from 'any-observable';\nimport { Observable as RxObservable } from 'rxjs';\nimport { Dictionary } from 'lodash';\nimport { Connection, Observer } from './connection';\nimport { Builder } from './builder';\nimport { ClauseCollection } from './clause-collection';\nimport { Clause, QueryObject } from './clause';\n\nexport class Query extends Builder<Query> {\n  protected clauses = new ClauseCollection();\n\n  /**\n   * Creates a new query with a given connection.\n   *\n   * @param {Connection} connection\n   */\n  constructor(protected connection: Connection | null = null) {\n    super();\n  }\n\n  protected continueChainClause(clause: Clause) {\n    return this.addClause(clause);\n  }\n\n  /**\n   * Runs this query on its connection. If this query was created by calling a\n   * chainable method of a connection, then its connection was automatically\n   * set.\n   *\n   * Returns a promise that resolves to an array of records. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .run();\n   * ```\n   *\n   * Would result in the value:\n   * ```\n   * [\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // first friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // second friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // third friend,\n   *   },\n   * ]\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. If you use lodash you can extract all of Steve's friends from the\n   * results like using `_.map(results, 'friends')`. If you don't, you can use\n   * ES2015/ES6: `results.map(record => record.friends)`.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>[]`.\n   *\n   * Throws an exception if this query does not have a connection or has no\n   * clauses.\n   *\n   * @returns {Promise<Dictionary<R>[]>}\n   */\n  run<R = any>(): Promise<Dictionary<R>[]> {\n    if (!this.connection) {\n      return AnyPromise.reject(\n        new Error('Cannot run query; no connection object available.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    return this.connection.run<R>(this);\n  }\n\n  /**\n   * Runs this query on its connection. If this query was created by calling a\n   * chainable method of a connection, then its connection was automatically\n   * set.\n   *\n   * Returns an observable that emits each record as it is received from the\n   * database. This is the most efficient way of working with very large\n   * datasets. Each record is an object where each key is the name of a variable\n   * that you specified in your return clause.\n   *\n   * Eg:\n   * ```typescript\n   * const result$ = connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .stream();\n   *\n   * // Emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // Then emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // And so on\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. You can extract all of steve's friends from the query by using RxJS\n   * operators:\n   * ```\n   * const friends$ = results$.map(row => row.friends);\n   * ```\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Observable<Dictionary<R>>`.\n   *\n   * Throws an exception if this query does not have a connection or has no\n   * clauses.\n   */\n  stream<R = any>(): RxObservable<Dictionary<R>> {\n    if (!this.connection) {\n      return new Observable((subscriber: Observer<Dictionary<R>>): void => {\n        subscriber.error(new Error('Cannot run query; no connection object available.'));\n      });\n    }\n\n    return this.connection.stream<R>(this);\n  }\n\n  /**\n   * Runs the current query on its connection and returns the first result.\n   * If the query was created by calling a chainable method of a connection,\n   * the query's connection was automatically set.\n   *\n   * If 0 results were returned from the database, returns `undefined`.\n   *\n   * Returns a promise that resolves to a single record. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>`. Note that this function returns\n   * `undefined` if the result set was empty.\n   */\n  first<R = any>(): Promise<Dictionary<R> | undefined> {\n    return this.run<R>().then(results => results && results.length > 0 ? results[0] : undefined);\n  }\n\n  // Clause proxied methods\n\n  /**\n   * Returns the query as a string with parameter variables.\n   *\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .build();\n   *\n   * // MATCH (steve { name: $name })-[:FriendsWith]->(friends)\n   * // RETURN steve, friends\n   * ```\n   *\n   * @returns {string}\n   */\n  build(): string {\n    return this.clauses.build();\n  }\n\n  /**\n   * Synonym for `build()`.\n   * @returns {string}\n   */\n  toString(): string {\n    return this.clauses.toString();\n  }\n\n  /**\n   * Returns an object that includes both the query and the params ready to be\n   * passed to the neo4j driver.\n   */\n  buildQueryObject(): QueryObject {\n    return this.clauses.buildQueryObject();\n  }\n\n  /**\n   * Like `build`, but will insert the values of the parameters into the string\n   * so queries are easier to debug. __Note: this should only ever be used for\n   * debugging__.\n   *\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .build();\n   *\n   * // MATCH (steve { name: 'Steve' })-[:FriendsWith]->(friends)\n   * // RETURN steve, friends\n   * ```\n   *\n   * @returns {string}\n   */\n  interpolate(): string {\n    return this.clauses.interpolate();\n  }\n\n  /**\n   * Returns an array of all the clauses in this query.\n   * @returns {Clause[]}\n   */\n  getClauses(): Clause[] {\n    return this.clauses.getClauses();\n  }\n\n  /**\n   * Adds a new clause to the query. You probably won't ever need to call this\n   * directly, but there is nothing stopping you.\n   *\n   * @param {Clause} clause\n   * @returns {this}\n   */\n  addClause(clause: Clause): this {\n    this.clauses.addClause(clause);\n    return this;\n  }\n}\n","// tslint:disable-next-line import-name\nimport AnyPromise from 'any-promise';\n// tslint:disable-next-line import-name\nimport Observable from 'any-observable';\n// import nodeCleanup from 'node-cleanup';\nimport { Dictionary, isFunction } from 'lodash';\nimport { AuthToken, Config, Driver, Session } from 'neo4j-driver/types/v1';\nimport { Transformer } from './transformer';\nimport { Query } from './query';\nimport neo4j from 'neo4j-driver/lib/browser/neo4j-web';\nimport { Builder } from './builder';\nimport { Clause } from './clause';\n\nlet connections: Connection[] = [];\n\n// Closes all open connections\n// nodeCleanup(() => {\n//   connections.forEach(con => con.close());\n//   connections = [];\n// });\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (error: any) => void;\n  complete: () => void;\n}\n\nexport type DriverConstructor = typeof neo4j.driver;\n\nexport interface FullConnectionOptions {\n  driverConstructor: DriverConstructor;\n  driverConfig: Config;\n}\n\nexport type ConnectionOptions = Partial<FullConnectionOptions>;\n\nexport interface Credentials { username: string; password: string; }\n\nfunction isCredentials(credentials: any): credentials is Credentials {\n  return 'username' in credentials && 'password' in credentials;\n}\n\n// We have to correct the type of lodash's isFunction method because it doesn't correctly narrow\n// union types such as the options parameter passed to the connection constructor.\nconst isTrueFunction: (value: any) => value is Function = isFunction;\n\n// tslint:disable max-line-length\n/**\n * The Connection class lets you access the Neo4j server and run queries against it. Under the hood,\n * the Connection class uses the official Neo4j Nodejs driver which manages connection pooling on a\n * [session basis]{@link https://neo4j.com/docs/api/javascript-driver/current/class/src/v1/driver.js~Driver.html#instance-method-session}.\n * It should be enough to have a single Connection instance per database per application.\n *\n * To create the connection, simply call the\n * [constructor]{@link https://jamesfer.me/cypher-query-builder/classes/connection.html#constructor}\n * and pass in the database url, username and password.\n * ```\n * const db = new Connection('bolt://localhost', {\n *   username: 'neo4j',\n *   password: 'password',\n * })\n * ```\n *\n * To use the connection, just start calling any of the clause methods such as `match`, `create` or\n * `matchNode` etc. They automatically create a {@link Query} object that you can then chain other\n * methods off of.\n * ```\n * db.matchNode('people', 'Person')\n *   .where({ 'people.age': greaterThan(18) })\n *   .return('people')\n *   .run()\n * ```\n *\n * You can also pass a query to the\n * [run]{@link https://jamesfer.me/cypher-query-builder/classes/connection.html#run} method,\n * however, this is probably much less convenient.\n * ```\n * db.run(\n *   new Query().matchNode('people', 'Person')\n *     .where({ 'people.age': greaterThan(18) })\n *     .return('people')\n *     .run()\n * );\n * ```\n *\n * Once you've finished with the connection you should close the connection.\n * ```\n * db.close()\n * ```\n *\n * The library will attempt to clean up all connections when the process exits, but it is better to\n * be explicit.\n */\n// tslint:enable max-line-length\nexport class Connection extends Builder<Query> {\n  protected auth: AuthToken;\n  protected driver: Driver;\n  protected options: FullConnectionOptions;\n  protected open: boolean;\n  protected transformer = new Transformer();\n\n  /**\n   * Creates a new connection to the database.\n   *\n   * @param url Url of the database such as `'bolt://localhost'`\n   * @param auth Auth can either be an object in the form `{ username: ..., password: ... }`, or a\n   * Neo4j AuthToken object which contains the `scheme`, `principal` and `credentials` properties\n   * for more advanced authentication scenarios. The AuthToken object is what is passed directly to\n   * the neo4j javascript driver so checkout their docs for more information on it.\n   * @param options Additional configuration options. If you provide a function instead of an\n   * object, it will be used as the driver constructor. While passing a driver constructor function\n   * here is not deprecated, it is the legacy way of setting it and you should prefer to pass an\n   * options object with the `driverConstructor` parameter.\n   * @param options.driverConstructor An optional driver constructor to use for\n   * this connection. Defaults to the official Neo4j driver. The constructor is\n   * given the url you pass to this constructor and an auth token that is\n   * generated from calling [`neo4j.auth.basic`]{@link\n   * https://neo4j.com/docs/api/javascript-driver/current#usage-examples}.\n   * @param options.driverConfig Neo4j options that are passed directly to the underlying driver.\n   */\n  constructor(\n    protected url: string,\n    auth: Credentials | AuthToken,\n    options: DriverConstructor | ConnectionOptions = neo4j.driver,\n  ) {\n    super();\n\n    this.auth = isCredentials(auth)\n      ? neo4j.auth.basic(auth.username, auth.password)\n      : auth;\n\n    const driverConstructor = isTrueFunction(options) ? options\n      : options.driverConstructor ? options.driverConstructor : neo4j.driver;\n    const driverConfig = isTrueFunction(options) || !options.driverConfig\n      ? {} : options.driverConfig;\n    this.options = { driverConstructor, driverConfig };\n    this.driver = driverConstructor(this.url, this.auth, this.options.driverConfig);\n    this.open = true;\n    connections.push(this);\n  }\n\n  /**\n   * Closes this connection if it is open. Closed connections cannot be\n   * reopened.\n   */\n  close() {\n    if (this.open) {\n      this.driver.close();\n      this.open = false;\n    }\n  }\n\n  /**\n   * Opens and returns a session. You should never need to use this directly.\n   * Your probably better off with `run` instead.\n   */\n  session(): Session | null {\n    if (this.open) {\n      return this.driver.session();\n    }\n    return null;\n  }\n\n  /**\n   * Returns a new query that uses this connection. The methods such as `match`\n   * or `create` are probably more useful to you as they automatically create a\n   * new chainable query for you.\n   * @return {Query}\n   */\n  query(): Query {\n    return new Query(this);\n  }\n\n  protected continueChainClause(clause: Clause) {\n    return this.query().addClause(clause);\n  }\n\n  /**\n   * Runs the provided query on this connection, regardless of which connection\n   * the query was created from. Each query is run on it's own session.\n   *\n   * Run returns a promise that resolves to an array of records. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .run();\n   * ```\n   *\n   * Would result in the value:\n   * ```\n   * [\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // first friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // second friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // third friend,\n   *   },\n   * ]\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. If you use lodash you can extract all of Steve's friends from the\n   * results like using `_.map(results, 'friends')`. If you don't, you can use\n   * ES2015/ES6: `results.map(record => record.friends)`.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>[]`.\n   *\n   * Throws an exception if this connection is not open or there are no clauses\n   * in the query.\n   *\n   * @param {Query} query\n   * @returns {Promise<Dictionary<R>[]>}\n   */\n  run<R = any>(query: Query): Promise<Dictionary<R>[]> {\n    if (!this.open) {\n      return AnyPromise.reject(\n        new Error('Cannot run query; connection is not open.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    if (query.getClauses().length === 0) {\n      return AnyPromise.reject(\n        new Error('Cannot run query: no clauses attached to the query.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    const session = this.session();\n    if (!session) {\n      throw Error('Cannot run query: connection is not open.');\n    }\n\n    const queryObj = query.buildQueryObject();\n    const result = session.run(queryObj.query, queryObj.params);\n\n    // Need to wrap promise in an any-promise\n    return AnyPromise.resolve(result)\n      .then((result) => {\n        session.close();\n        return this.transformer.transformRecords<R>(result.records);\n      })\n      .catch((error) => {\n        session.close();\n        return Promise.reject(error);\n      }) as Promise<Dictionary<R>[]>;\n  }\n\n  /**\n   * Runs the provided query on this connection, regardless of which connection\n   * the query was created from. Each query is run on it's own session.\n   *\n   * Returns an observable that emits each record as it is received from the\n   * database. This is the most efficient way of working with very large\n   * datasets. Each record is an object where each key is the name of a variable\n   * that you specified in your return clause.\n   *\n   * Eg:\n   * ```typescript\n   * const results$ = connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .stream();\n   *\n   * // Emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // Then emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // And so on\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. You can extract all of steve's friends from the query by using\n   * operators:\n   * ```\n   * const friends$ = results$.map(row => row.friends);\n   * ```\n   *\n   * The observable class that is used is imported from\n   * [any-observable](https://github.com/sindresorhus/any-observable) by default\n   * it uses rxjs for the observables, but you can pick a different implementation\n   * by registering it with any-observable before importing this module.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>`.\n   *\n   * Throws an exception if this connection is not open or there are no clauses\n   * in the query.\n   *\n   * The query is run when you call stream so you should subscribe to the results\n   * immediately to prevent missing any data.\n   *\n   * Due to the way the Neo4j javascript driver works, once you call stream there\n   * is no way to stop the query until it is complete. Even if you unsubscribe from\n   * the observable, all the remaining rows will still be parsed by the driver but\n   * then immediately discarded.\n   * ```typescript\n   * const results$ = connection.matchNode('records')\n   *   .return('records')\n   *   .limit(1000) // 1000 records will be loaded and parsed from the database\n   *   .stream()\n   *   .take(10) // even though you only take the first 10\n   *   .subscribe(record => {});\n   * ```\n   * In practice this should never happen unless you're doing some strange things.\n   */\n  stream<R = any>(query: Query): Observable<Dictionary<R>> {\n    return new Observable((subscriber: Observer<Dictionary<R>>): void => {\n      if (!this.open) {\n        subscriber.error(new Error('Cannot run query; connection is not open.'));\n        return;\n      }\n\n      if (query.getClauses().length === 0) {\n        subscriber.error(Error('Cannot run query: no clauses attached to the query.'));\n        return;\n      }\n\n      const session = this.session();\n      if (!session) {\n        throw Error('Cannot run query: connection is not open.');\n      }\n\n      // Run the query\n      const queryObj = query.buildQueryObject();\n      const result = session.run(queryObj.query, queryObj.params);\n\n      // Subscribe to the result and clean up the session\n      // Note: Neo4j observables use a different subscribe syntax to RxJS observables\n      result.subscribe({\n        onNext: (record) => {\n          if (!subscriber.closed) {\n            subscriber.next(this.transformer.transformRecord<R>(record));\n          }\n        },\n        onError: (error) => {\n          session.close();\n          if (!subscriber.closed) {\n            subscriber.error(error);\n          }\n        },\n        onCompleted: () => {\n          session.close();\n          if (!subscriber.closed) {\n            subscriber.complete();\n          }\n        },\n      });\n    });\n  }\n}\n"],"names":["uniqueString","str","existing","camelString","number","matches","match","substr","length","regex","RegExp","takenSuffixes","suffixes","existingString","suffix","push","indexOf","Math","max","stringifyValue","value","join","pairs","el","key","stringifyLabels","labels","relation","stringifyPathLength","bounds","lower","upper","Parameter","constructor","name","toString","ParameterBag","getName","parameterMap","addParam","actualName","param","addExistingParam","getParams","deleteParam","importParams","other","getParam","ParameterContainer","useParameterBag","newBag","parameterBag","getParameterBag","Clause","build","buildQueryObject","query","params","interpolate","pattern","replace","Pattern","conditions","options","expanded","isConditions","a","tempName","tempLabels","tempConditions","undefined","TypeError","setExpandedConditions","useExpandedConditions","rebindConditionParams","conditionParams","getNameString","getLabelsString","getConditionsParamString","strings","NodePattern","isPathLengthArray","item","isPathLength","RelationPattern","dir","tempLength","arrows","in","out","either","PatternClause","patterns","defaultOptions","arr","forEach","pat","patternStrings","clause","Create","unique","TermListClause","terms","term","stringifyTerm","stringifyProperty","stringifyProperties","stringifyDictionary","prop","alias","node","prefix","props","convertToString","list","With","Unwind","listParam","Delete","variables","detach","Set","values","valueIsObject","op","merge","operationStrings","makeLabelStatement","makeValueStatement","makeVariableStatement","Match","optional","Remove","properties","property","Return","distinct","Skip","amount","amountParam","Limit","comparisions","equals","greaterThan","greaterEqualTo","lessThan","lessEqualTo","startsWith","endsWith","contains","inArray","hasLabel","exists","between","isNull","regexp","compare","operator","variable","paramName","baseParamName","split","parts","exp","insensitive","stringExp","lowerInclusive","upperInclusive","lowerOp","upperOp","lowerComparator","upperComparator","lowerConstraint","upperConstraint","label","Precedence","WhereOp","stringifyCondition","condition","conditionName","stringCons","precedence","None","combineOr","combineAnd","evaluate","combineNot","string","Not","braces","newPrecedence","Or","combineXor","Xor","namePrefix","And","Where","Raw","args","Object","hasOwnProperty","call","queryParams","OrderBy","fields","direction","normalizeDirection","constraints","field","fieldDirection","upperDir","toUpperCase","isDescending","Merge","OnMatch","OnCreate","operators","and","or","xor","not","WhereAnd","WhereOr","WhereXor","WhereNot","Union","all","SetBlock","chain","wrapper","set","wrap","setLabels","setValues","setVariables","Builder","c","continueChainClause","bind","create","createUnique","createNode","createUniqueNode","delete","detachDelete","limit","matchNode","optionalMatch","orderBy","raw","remove","removeProperties","removeLabels","return","returnDistinct","skip","union","unionAll","unwind","where","with","Transformer","transformRecords","records","rec","transformRecord","record","toObject","transformValue","isPlainValue","v","neo4j","isInt","convertInteger","isNode","transformNode","isRelation","transformRelation","type","identity","integer","rel","start","end","num","inSafeRange","toNumber","ClauseCollection","getClauses","clauses","addClause","s","Query","connection","run","AnyPromise","reject","Error","stream","Observable","subscriber","error","first","then","results","isCredentials","credentials","isTrueFunction","Connection","url","auth","driver","basic","username","password","driverConstructor","driverConfig","open","connections","close","session","queryObj","result","resolve","transformer","catch","Promise","subscribe","onNext","closed","next","onError","onCompleted","complete"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;AAOA,SAAgBA,aAAaC,KAAaC;MACpCC,WAAW,GAAG,WAAUF,GAAV,CAAlB;;;MAGIG,MAAM,GAAG,IAAb;QACMC,OAAO,GAAGF,WAAW,CAACG,KAAZ,CAAkB,SAAlB,CAAhB;;MACID,OAAJ,EAAa;IACXD,MAAM,GAAG,CAACC,OAAO,CAAC,CAAD,CAAjB;IACAF,WAAW,GAAGA,WAAW,CAACI,MAAZ,CAAmB,CAAnB,EAAsBJ,WAAW,CAACK,MAAZ,GAAqBH,OAAO,CAAC,CAAD,CAAP,CAAWG,MAAtD,CAAd;;;;QAIIC,KAAK,GAAG,IAAIC,MAAJ,KAAeP,sBAAf,CAAd;;QACMQ,aAAa,GAAG,QACpBT,QADoB,EAEpB,CAACU,QAAD,EAAWC,cAAX;UACQR,OAAO,GAAGQ,cAAc,CAACP,KAAf,CAAqBG,KAArB,CAAhB;;QACIJ,OAAJ,EAAa;YACL,GAAGS,MAAH,IAAaT,OAAnB;MACAO,QAAQ,CAACG,IAAT,CAAcD,MAAM,GAAG,CAACA,MAAJ,GAAa,CAAjC;;;WAEKF,QAAP;GARkB,EAUpB,EAVoB,CAAtB;;;;MAeI,CAACR,MAAD,IAAWO,aAAa,CAACK,OAAd,CAAsBZ,MAAtB,MAAkC,CAAC,CAAlD,EAAqD;IACnDA,MAAM,GAAGa,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,GAAGP,aAAf,IAAgC,CAAzC;;;;SAIKR,WAAW,IAAIC,MAAM,KAAK,CAAX,GAAe,EAAf,GAAoBA,MAAxB,CAAlB;;;;;;;;AAQF,SAAgBe,eAAeC;MACzB,UAASA,KAAT,KAAmB,WAAUA,KAAV,CAAvB,EAAyC;cAC7BA,OAAV;;;MAEE,UAASA,KAAT,CAAJ,EAAqB;eACRA,QAAX;;;MAEE,SAAQA,KAAR,CAAJ,EAAoB;UACZnB,GAAG,GAAG,KAAImB,KAAJ,EAAWD,cAAX,EAA2BE,IAA3B,CAAgC,IAAhC,CAAZ;;gBACYpB,OAAZ;;;MAEE,UAASmB,KAAT,CAAJ,EAAqB;UACbE,KAAK,GAAG,KAAIF,KAAJ,EAAW,CAACG,EAAD,EAAKC,GAAL,QAAgBA,QAAQL,cAAc,CAACI,EAAD,GAAjD,CAAd;;UACMtB,GAAG,GAAGqB,KAAK,CAACD,IAAN,CAAW,IAAX,CAAZ;gBACYpB,OAAZ;;;SAEK,EAAP;;;;;;;;;;AAUF,SAAgBwB,gBAAgBC,QAAsBC,QAAQ,GAAG;MAC3DD,MAAM,CAAClB,MAAP,KAAkB,CAAtB,EAAyB;WAChB,EAAP;;;aAES,WAAUkB,MAAV,EAAkBL,IAAlB,CAAuBM,QAAQ,GAAG,GAAH,GAAS,GAAxC,GAAX;;;;;;;;AAaF,SAAgBC,oBAAoBC;MAC9B,OAAMA,MAAN,CAAJ,EAAmB;WACV,EAAP;;;MAGEA,MAAM,KAAK,GAAf,EAAoB;WACX,GAAP;;;MAGE,UAASA,MAAT,CAAJ,EAAsB;eACTA,QAAX;;;QAGIC,KAAK,GAAG,OAAMD,MAAM,CAAC,CAAD,CAAZ,IAAmB,EAAnB,MAA2BA,MAAM,CAAC,CAAD,GAA/C;QACME,KAAK,GAAG,OAAMF,MAAM,CAAC,CAAD,CAAZ,IAAmB,EAAnB,MAA2BA,MAAM,CAAC,CAAD,GAA/C;SACOC,KAAK,IAAIC,KAAT,OAAqBD,UAAUC,OAA/B,GAAyC,GAAhD;;;MCrHWC;EACXC,YACSC,MACAd;aADA,GAAAc,IAAA;cACA,GAAAd,KAAA;;;EAGTe,QAAQ;eACK,KAAKD,MAAhB;;;;AAIJ,MAAaE;EAAbH;qBACY,GAAsC,EAAtC;;;;;;;;EAMVI,OAAO,CAACH,IAAI,GAAG,GAAR;WACElC,YAAY,CAACkC,IAAD,EAAO,MAAK,KAAKI,YAAV,CAAP,CAAnB;;;;;;;;;;EASFC,QAAQ,CAACnB,KAAD,EAAac,IAAb;UACAM,UAAU,GAAG,KAAKH,OAAL,CAAaH,IAAb,CAAnB;UACMO,KAAK,GAAG,IAAIT,SAAJ,CAAcQ,UAAd,EAA0BpB,KAA1B,CAAd;SACKkB,YAAL,CAAkBE,UAAlB,IAAgCC,KAAhC;WACOA,KAAP;;;;;;;;;;EASFC,gBAAgB,CAACD,KAAD;IACdA,KAAK,CAACP,IAAN,GAAa,KAAKG,OAAL,CAAaI,KAAK,CAACP,IAAnB,CAAb;SACKI,YAAL,CAAkBG,KAAK,CAACP,IAAxB,IAAgCO,KAAhC;WACOA,KAAP;;;;;;;;;EAQFE,SAAS;WACA,WAAU,KAAKL,YAAf,EAA6B,OAA7B,CAAP;;;;;;;;EAOFM,WAAW,CAACV,IAAD;WACF,KAAKI,YAAL,CAAkBJ,IAAlB,CAAP;;;;;;;EAMFW,YAAY,CAACC,KAAD;SACL,MAAMtB,GAAX,IAAkBsB,KAAK,CAACR,YAAxB,EAAsC;WAC/BI,gBAAL,CAAsBI,KAAK,CAACR,YAAN,CAAmBd,GAAnB,CAAtB;;;;;;;;EAOJuB,QAAQ,CAACb,IAAD;WACC,KAAKI,YAAL,CAAkBJ,IAAlB,CAAP;;;;;MC7ESc;EAAbf;qBACY,GAAe,IAAIG,YAAJ,EAAf;;;EAEVa,eAAe,CAACC,MAAD;IACbA,MAAM,CAACL,YAAP,CAAoB,KAAKM,YAAzB;SACKA,YAAL,GAAoBD,MAApB;;;EAGFP,SAAS;WACA,KAAKQ,YAAL,CAAkBR,SAAlB,EAAP;;;;;;;;;;EASFJ,QAAQ,CAACnB,KAAD,EAAac,IAAb;WACC,KAAKiB,YAAL,CAAkBZ,QAAlB,CAA2BnB,KAA3B,EAAkCc,IAAlC,CAAP;;;EAGFkB,eAAe;WACN,KAAKD,YAAZ;;;;;MCjBkBE,eAAeL;;;;;EAWnCb,QAAQ;WACC,KAAKmB,KAAL,EAAP;;;;;;;;EAOFC,gBAAgB;WACP;MACLC,KAAK,EAAE,KAAKF,KAAL,EADF;MAELG,MAAM,EAAE,KAAKd,SAAL;KAFV;;;;;;;;;EAWFe,WAAW;QACLF,KAAK,GAAG,KAAKF,KAAL,EAAZ;UACMG,MAAM,GAAG,KAAKd,SAAL,EAAf;;SACK,MAAMT,IAAX,IAAmBuB,MAAnB,EAA2B;YACnBE,OAAO,GAAG,IAAIjD,MAAJ,OAAiBwB,sBAAjB,EAAyC,GAAzC,CAAhB;MACAsB,KAAK,GAAGA,KAAK,CAACI,OAAN,CAAcD,OAAd,EAAuBxC,cAAc,CAACsC,MAAM,CAACvB,IAAD,CAAP,CAArC,CAAR;;;WAEKsB,KAAP;;;;;MCvCkBK,gBAAgBR;EAOpCpB,YACEC,MACAR,QACAoC,YACUC,UAAU;IAAEC,QAAQ,EAAE;;;gBAAtB,GAAAD,OAAA;wBATF,GAAqD,EAArD;;UAYFE,YAAY,GAAIC,CAAD,IAAkC,cAAaA,CAAb,KAAmB,CAAC,SAAQA,CAAR,CAA3E;;QACIC,QAAQ,GAAGjC,IAAf;QACIkC,UAAU,GAAG1C,MAAjB;QACI2C,cAAc,GAAGP,UAArB;;QAEI,OAAMO,cAAN,CAAJ,EAA2B;UACrBJ,YAAY,CAACG,UAAD,CAAhB,EAA8B;QAC5BC,cAAc,GAAGD,UAAjB;QACAA,UAAU,GAAGE,SAAb;OAFF,MAGO,IAAI,OAAMF,UAAN,KAAqBH,YAAY,CAACE,QAAD,CAArC,EAAiD;QACtDE,cAAc,GAAGF,QAAjB;QACAA,QAAQ,GAAGG,SAAX;OAFK,MAGA;QACLD,cAAc,GAAG,EAAjB;;;;QAIA,OAAMD,UAAN,CAAJ,EAAuB;UACjB,SAAQD,QAAR,CAAJ,EAAuB;QACrBC,UAAU,GAAGD,QAAb;QACAA,QAAQ,GAAGG,SAAX;OAFF,MAGO;QACLF,UAAU,GAAG,EAAb;;;;QAIA,OAAMD,QAAN,CAAJ,EAAqB;MACnBA,QAAQ,GAAG,EAAX;;;QAGE,CAAC,UAASA,QAAT,CAAL,EAAyB;YACjB,IAAII,SAAJ,CAAc,wBAAd,CAAN;;;QAEE,CAAC,UAASH,UAAT,CAAD,IAAyB,CAAC,SAAQA,UAAR,CAA9B,EAAmD;YAC3C,IAAIG,SAAJ,CAAc,qCAAd,CAAN;;;QAEE,CAACN,YAAY,CAACI,cAAD,CAAjB,EAAmC;YAC3B,IAAIE,SAAJ,CAAc,+BAAd,CAAN;;;SAGG7C,MAAL,GAAc,WAAU0C,UAAV,CAAd;SACKlC,IAAL,GAAYiC,QAAZ;SACKL,UAAL,GAAkBO,cAAlB;SACKG,qBAAL,CAA2BT,OAAO,CAACC,QAAnC;;;EAGFQ,qBAAqB,CAACR,QAAD;QACf,KAAKS,qBAAL,KAA+BT,QAAnC,EAA6C;WACtCS,qBAAL,GAA6BT,QAA7B;WACKU,qBAAL;;;;EAIJA,qBAAqB;;QAEf,KAAKC,eAAL,YAAgC3C,SAApC,EAA+C;WACxCmB,YAAL,CAAkBP,WAAlB,CAA8B,KAAK+B,eAAL,CAAqBzC,IAAnD;KADF,MAEO;WACA,MAAMV,GAAX,IAAkB,KAAKmD,eAAvB,EAAwC;aACjCxB,YAAL,CAAkBP,WAAlB,CAA8B,KAAK+B,eAAL,CAAqBnD,GAArB,EAA0BU,IAAxD;;;;;QAKA,CAAC,SAAQ,KAAK4B,UAAb,CAAL,EAA+B;UACzB,KAAKW,qBAAT,EAAgC;aACzBE,eAAL,GAAuB,WAAU,KAAKb,UAAf,EAA2B,CAAC1C,KAAD,EAAQc,IAAR;iBACzC,KAAKiB,YAAL,CAAkBZ,QAAlB,CAA2BnB,KAA3B,EAAkCc,IAAlC,CAAP;SADqB,CAAvB;OADF,MAIO;aACAyC,eAAL,GAAuB,KAAKxB,YAAL,CAAkBZ,QAAlB,CAA2B,KAAKuB,UAAhC,EAA4C,YAA5C,CAAvB;;KANJ,MAQO;WACAa,eAAL,GAAuB,EAAvB;;;;EAIJC,aAAa;WACJ,KAAK1C,IAAL,GAAY,KAAKA,IAAjB,GAAwB,EAA/B;;;EAGF2C,eAAe,CAAClD,QAAQ,GAAG,KAAZ;WACNF,eAAe,CAAC,KAAKC,MAAN,EAAcC,QAAd,CAAtB;;;EAGFmD,wBAAwB;QAClB,SAAQ,KAAKhB,UAAb,CAAJ,EAA8B;aACrB,EAAP;;;QAGE,KAAKW,qBAAT,EAAgC;YACxBM,OAAO,GAAG,KAAI,KAAKJ,eAAT,EAA0B,CAAClC,KAAD,EAAQP,IAAR;kBAC9BA,SAASO,OAAnB;OADc,CAAhB;;kBAGYsC,OAAO,CAAC1D,IAAR,CAAa,IAAb,KAAZ;;;WAEK,KAAKsD,eAAL,CAAqBxC,QAArB,EAAP;;;;;MCnHS6C,oBAAoBnB;EAC/B5B,YACEC,MACAR,QACAoC;UAEM5B,IAAN,EAAYR,MAAZ,EAAoBoC,UAApB;;;EAGFR,KAAK;QACCE,KAAK,GAAG,KAAKoB,aAAL,EAAZ;IACApB,KAAK,IAAI,KAAKqB,eAAL,EAAT;IACArB,KAAK,QAAQ,KAAKsB,wBAAL,IAAb;eACW,MAAKtB,KAAL,IAAX;;;;;ACZJ,MAAMyB,iBAAiB,GAAI7D,KAAD,IACxB,SAAQA,KAAR,KAAkB,OAAMA,KAAN,EAAa8D,IAAI,IAAI,UAASA,IAAT,KAAkB,OAAMA,IAAN,CAAvC,CAAlB,IAAyE9D,KAAK,CAACZ,MAAN,GAAe,CAD1F;;AAGA,MAAM2E,YAAY,GAAI/D,KAAD,IACnBA,KAAK,KAAK,GAAV,IAAiB,UAASA,KAAT,CAAjB,IAAoC6D,iBAAiB,CAAC7D,KAAD,CADvD;;AAMA,MAAagE,wBAAwBvB;EAInC5B,YACEoD,KACAnD,MACAR,QACAoC,YACAtD;QAEI2D,QAAQ,GAAGjC,IAAf;QACIkC,UAAU,GAAG1C,MAAjB;QACI2C,cAAc,GAAGP,UAArB;QACIwB,UAAU,GAAG9E,MAAjB;;QAEI,OAAM8E,UAAN,CAAJ,EAAuB;UACjBH,YAAY,CAACd,cAAD,CAAhB,EAAkC;QAChCiB,UAAU,GAAGjB,cAAb;QACAA,cAAc,GAAGC,SAAjB;OAFF,MAGO,IAAI,OAAMD,cAAN,KAAyBc,YAAY,CAACf,UAAD,CAAzC,EAAuD;QAC5DkB,UAAU,GAAGlB,UAAb;QACAA,UAAU,GAAGE,SAAb;OAFK,MAGA,IAAI,OAAMD,cAAN,KAAyB,OAAMD,UAAN,CAAzB,IAA8Ce,YAAY,CAAChB,QAAD,CAA9D,EAA0E;QAC/EmB,UAAU,GAAGnB,QAAb;QACAA,QAAQ,GAAGG,SAAX;;;;QAIAa,YAAY,CAAChB,QAAD,CAAZ,IAA0BgB,YAAY,CAACf,UAAD,CAAtC,IAAsDe,YAAY,CAACd,cAAD,CAAtE,EAAwF;YAChF,IAAIE,SAAJ,CAAc,+BAAd,CAAN;;;UAGIJ,QAAN,EAAgBC,UAAhB,EAA4BC,cAA5B;SACKgB,GAAL,GAAWA,GAAX;SACK7E,MAAL,GAAc8E,UAAd;;;EAGFhC,KAAK;UACGpB,IAAI,GAAG,KAAK0C,aAAL,EAAb;UACMlD,MAAM,GAAG,KAAKmD,eAAL,CAAqB,IAArB,CAAf;UACMrE,MAAM,GAAGoB,mBAAmB,CAAC,KAAKpB,MAAN,CAAlC;UACMsD,UAAU,GAAG,KAAKgB,wBAAL,EAAnB;;UACMtB,KAAK,GAAG,SAAQtB,OAAOR,SAASlB,UAAUsD,YAAlC,CAAd;;UAEMyB,MAAM,GAA8C;MACxDC,EAAE,EAAE,CAAC,IAAD,EAAO,GAAP,CADoD;MAExDC,GAAG,EAAE,CAAC,GAAD,EAAM,IAAN,CAFmD;MAGxDC,MAAM,EAAE,CAAC,GAAD,EAAM,GAAN;KAHV;WAKOH,MAAM,CAAC,KAAKF,GAAN,CAAN,CAAiBhE,IAAjB,CAAsBmC,KAAK,CAAChD,MAAN,GAAe,CAAf,OAAuBgD,QAAvB,GAAkC,EAAxD,CAAP;;;;;MCrDSmC,sBAAsBtC;EAGjCpB,YACE2D,UACA7B,UAA0B;IAAEU,qBAAqB,EAAE;;;UAG7CoB,cAAc,GAAG;MACrBpB,qBAAqB,EAAE;KADzB;;UAGM;MAAEA;QAA0B,QAAOoB,cAAP,EAAuB9B,OAAvB,CAAlC;;;UAGM+B,GAAG,GAAG,WAA+BF,QAA/B,CAAZ;;SACKA,QAAL,GAAiB,SAAQE,GAAG,CAAC,CAAD,CAAX,IAAkBA,GAAlB,GAAwB,CAACA,GAAD,CAAzC;;SAGKF,QAAL,CAAcG,OAAd,CAAsBD,GAAG,IAAIA,GAAG,CAACC,OAAJ,CAAaC,GAAD;MACvCA,GAAG,CAACxB,qBAAJ,CAA0BC,qBAA1B;MACAuB,GAAG,CAAC/C,eAAJ,CAAoB,KAAKE,YAAzB;KAF2B,CAA7B;;;EAMFG,KAAK;UACG2C,cAAc,GAAG,KAAI,KAAKL,QAAT,EAAoBjC,OAAD;aACjC,QAAOA,OAAP,EAAgB,CAAC1D,GAAD,EAAMiG,MAAN,KAAiBjG,GAAG,GAAGiG,MAAM,CAAC5C,KAAP,EAAvC,EAAuD,EAAvD,CAAP;KADqB,CAAvB;;WAGO2C,cAAc,CAAC5E,IAAf,CAAoB,IAApB,CAAP;;;;;MChCS8E,eAAeR;EAC1B1D,YAAY2D,UAAuC7B,UAAyB;UACpE6B,QAAN,EAAgB;MAAEnB,qBAAqB,EAAE;KAAzC;gBADiD,GAAAV,OAAA;;;EAInDT,KAAK;UACG8C,MAAM,GAAG,KAAKrC,OAAL,CAAaqC,MAAb,GAAsB,SAAtB,GAAkC,EAAjD;oBACgBA,UAAU,MAAM9C,KAAN,IAA1B;;;;;MCMS+C,uBAAuBhD;;;;;;;;;;EAYlCpB,YAAYqE;;SAELA,KAAL,GAAa,WAAUA,KAAV,CAAb;;;EAGFnE,QAAQ;WACC,aAAY,KAAKmE,KAAjB,EAAwBC,IAAI,IAAI,KAAKC,aAAL,CAAmBD,IAAnB,CAAhC,EAA0DlF,IAA1D,CAA+D,IAA/D,CAAP;;;EAGMmF,aAAa,CAACD,IAAD;;QAEf,UAASA,IAAT,CAAJ,EAAoB;aACX,KAAKE,iBAAL,CAAuBF,IAAvB,CAAP;;;;QAIE,SAAQA,IAAR,CAAJ,EAAmB;aACV,KAAKG,mBAAL,CAAyBH,IAAzB,CAAP;;;;QAIE,eAAcA,IAAd,CAAJ,EAAyB;aAChB,KAAKI,mBAAL,CAAyBJ,IAAzB,CAAP;;;WAGK,EAAP;;;EAGME,iBAAiB,CAACG,IAAD,EAAeC,KAAf,EAA+BC,IAA/B;QACnBC,MAAM,GAAGD,IAAI,MAAMA,OAAN,GAAgB,EAAjC;;QACID,KAAJ,EAAW;MACTE,MAAM,OAAOF,WAAb;;;WAEKE,MAAM,GAAGH,IAAhB;;;EAGMF,mBAAmB,CAACM,KAAD,EAAoBH,KAApB,EAAoCC,IAApC;UACnBG,eAAe,GAAG,CAACC,IAAD,EAAiBN,IAAjB;UAClB,UAASA,IAAT,CAAJ,EAAoB;;QAElBM,IAAI,CAACnG,IAAL,CAAU,KAAK0F,iBAAL,CAAuBG,IAAvB,EAA6BC,KAA7B,EAAoCC,IAApC,CAAV;OAFF,MAGO;;QAELI,IAAI,CAACnG,IAAL,CAAU,GAAG,KAAI6F,IAAJ,EAAU,CAAC1E,IAAD,EAAO2E,KAAP,KAAiB,KAAKJ,iBAAL,CAAuBvE,IAAvB,EAA6B2E,KAA7B,EAAoCC,IAApC,CAA3B,CAAb;;;aAEKI,IAAP;KARF;;WAUO,QAAOF,KAAP,EAAcC,eAAd,EAA+B,EAA/B,CAAP;;;EAGMN,mBAAmB,CAACG,IAAD;WAClB,QACLA,IADK,EAEL,CAACI,IAAD,EAAON,IAAP,EAAapF,GAAb;UACM,UAASoF,IAAT,CAAJ,EAAoB;;QAElBM,IAAI,CAACnG,IAAL,CAAU,KAAK0F,iBAAL,CAAuBG,IAAvB,EAA6BpF,GAA7B,CAAV;OAFF,MAGO;;QAEL0F,IAAI,CAACnG,IAAL,CAAU,GAAG,KAAK2F,mBAAL,CAAyBE,IAAzB,EAA+BtC,SAA/B,EAA0C9C,GAA1C,CAAb;;;aAEK0F,IAAP;KAVG,EAYL,EAZK,CAAP;;;EAgBF5D,KAAK;WACI,KAAKnB,QAAL,EAAP;;;;;MChGSgF,aAAad;;;;;EAKxBpE,YAAYqE;UACJA,KAAN;;;EAGFhD,KAAK;mBACY,MAAMA,KAAN,IAAf;;;;;MCVS8D,eAAe/D;EAG1BpB,YACYiF,MACAhF;;aADA,GAAAgF,IAAA;aACA,GAAAhF,IAAA;SAGLmF,SAAL,GAAiB,KAAKlE,YAAL,CAAkBZ,QAAlB,CAA2B,KAAK2E,IAAhC,EAAsC,MAAtC,CAAjB;;;EAGF5D,KAAK;qBACc,KAAK+D,gBAAgB,KAAKnF,MAA3C;;;;;MCRSoF,eAAejE;EAG1BpB,YACEsF,WACUxD,UAAyB;;gBAAzB,GAAAA,OAAA;SAGLwD,SAAL,GAAiB,WAAUA,SAAV,CAAjB;;;EAGFjE,KAAK;UACGkE,MAAM,GAAG,KAAKzD,OAAL,CAAayD,MAAb,GAAsB,SAAtB,GAAkC,EAAjD;cACUA,gBAAgB,KAAKD,SAAL,CAAelG,IAAf,CAAoB,IAApB,GAA1B;;;;;MCFSoG,YAAYpE;EAyBvBpB,YACE;IAAEP,MAAF;IAAUgG,MAAV;IAAkBH;KAClBxD,UAAsB;;;2BArBd,GAAqB,CAACrC,MAAD,EAAuBF,GAAvB;aACtBA,GAAG,GAAGC,eAAe,CAACC,MAAD,CAA5B;KADQ;;2BAIA,GAAqB,CAACN,KAAD,EAAaI,GAAb;YACvBmG,aAAa,GAAGvG,KAAK,YAAYY,SAAjB,GAA6B,UAASZ,KAAK,CAACA,KAAf,CAA7B,GAAqD,UAASA,KAAT,CAA3E;YACMwG,EAAE,GAAG,KAAKC,KAAL,IAAcF,aAAd,GAA8B,MAA9B,GAAuC,KAAlD;aACOnG,GAAG,GAAGoG,EAAN,GAAWxG,KAAlB;KAHQ;;8BAMA,GAAwB,CAACA,KAAD,EAAqCI,GAArC;YAC1BoG,EAAE,GAAG,KAAKC,KAAL,GAAa,MAAb,GAAsB,KAAjC;;UACI,UAASzG,KAAT,CAAJ,EAAqB;eACZI,GAAG,GAAGoG,EAAN,GAAWxG,KAAlB;;;YAEI0G,gBAAgB,GAAG,KAAI1G,KAAJ,EAAW,CAACA,KAAD,EAAQwF,IAAR,QAAoBpF,OAAOoF,OAAOgB,KAAKxG,OAAlD,CAAzB;;aACO0G,gBAAgB,CAACzG,IAAjB,CAAsB,IAAtB,CAAP;KANQ;;SAeHK,MAAL,GAAc,WAAUA,MAAV,aAAd;SACKgG,MAAL,GAAc,WAAUA,MAAV,EAAkB,CAACtG,KAAD,EAAQc,IAAR;aACvB,KAAKiB,YAAL,CAAkBZ,QAAlB,CAA2BnB,KAA3B,EAAkCc,IAAlC,CAAP;KADY,CAAd;SAGKqF,SAAL,GAAiBA,SAAS,IAAI,EAA9B;SACKM,KAAL,GAAa,CAAC,CAAC9D,OAAO,CAAC8D,KAAvB;;;EAGFvE,KAAK;UACG5B,MAAM,GAAG,KAAI,KAAKA,MAAT,EAAiB,KAAKqG,kBAAtB,CAAf;;UACML,MAAM,GAAG,KAAI,KAAKA,MAAT,EAAiB,KAAKM,kBAAtB,CAAf;;UACMT,SAAS,GAAG,KAAI,KAAKA,SAAT,EAAoB,KAAKU,qBAAzB,CAAlB;;kBACc,QAAOvG,MAAP,EAAegG,MAAf,EAAuBH,SAAvB,EAAkClG,IAAlC,CAAuC,IAAvC,GAAd;;;;;MCvDS6G,cAAcvC;EACzB1D,YACE2D,UACU7B,UAAwB;IAAEoE,QAAQ,EAAE;;UAExCvC,QAAN,EAAgB;MAAEnB,qBAAqB,EAAE;KAAzC;gBAFU,GAAAV,OAAA;;;EAKZT,KAAK;QACCrD,GAAG,GAAG,QAAV;;QACI,KAAK8D,OAAL,CAAaoE,QAAjB,EAA2B;MACzBlI,GAAG,eAAeA,KAAlB;;;WAEKA,GAAG,GAAG,MAAMqD,KAAN,EAAb;;;;;MCVS8E,eAAe/E;EAI1BpB,YAAY;IAAEP,MAAM,GAAG,EAAX;IAAe2G,UAAU,GAAG;;;SAEjC3G,MAAL,GAAc,WAAUA,MAAV,aAAd;SACK2G,UAAL,GAAkB,WAAUA,UAAV,aAAlB;;;EAGF/E,KAAK;UACG5B,MAAM,GAAG,KAAI,KAAKA,MAAT,EAAiB,CAACA,MAAD,EAASF,GAAT,KAAiBA,GAAG,GAAGC,eAAe,CAACC,MAAD,CAAvD,CAAf;;UACM2G,UAAU,GAAG,SAAQ,KAAKA,UAAb,EAAyB,CAACA,UAAD,EAAa7G,GAAb,KAC1C,KAAI6G,UAAJ,EAAgBC,QAAQ,OAAO9G,OAAO8G,UAAtC,CADiB,CAAnB;;qBAGiB,CAAC,GAAG5G,MAAJ,EAAY,GAAG2G,UAAf,EAA2BhH,IAA3B,CAAgC,IAAhC,GAAjB;;;;;MCjBSkH,eAAelC;EAC1BpE,YAAYqE,OAA6BvC,UAAyB;UAC1DuC,KAAN;gBADuC,GAAAvC,OAAA;;;EAIzCT,KAAK;UACGkF,QAAQ,GAAG,KAAKzE,OAAL,CAAayE,QAAb,GAAwB,WAAxB,GAAsC,EAAvD;oBACgBA,YAAY,MAAMlF,KAAN,IAA5B;;;;;MCXSmF,aAAapF;EAGxBpB,YAAmByG;;eAAA,GAAAA,MAAA;SAEZC,WAAL,GAAmB,KAAKpG,QAAL,CAAcmG,MAAd,EAAsB,WAAtB,CAAnB;;;EAGFpF,KAAK;mBACY,KAAKqF,aAApB;;;;;MCTSC,cAAcvF;EAGzBpB,YAAmByG;;eAAA,GAAAA,MAAA;SAEZC,WAAL,GAAmB,KAAKpG,QAAL,CAAcmG,MAAd,EAAsB,YAAtB,CAAnB;;;EAGFpF,KAAK;oBACa,KAAKqF,aAArB;;;;;MCTSE,YAAY,GAAG;EAC1BC,MAD0B;EAE1BC,WAF0B;EAG1BC,cAH0B;EAI1BC,QAJ0B;EAK1BC,WAL0B;EAM1BC,UAN0B;EAO1BC,QAP0B;EAQ1BC,QAR0B;EAS1BC,OAT0B;EAU1BC,QAV0B;EAW1BC,MAX0B;EAY1BC,OAZ0B;EAa1BC,MAb0B;EAc1BC;CAdK;;AAmBP,SAASC,OAAT,CAAiBC,QAAjB,EAAmCzI,KAAnC,EAA+C0I,QAA/C,EAAmEC,SAAnE;SACS,CAACtG,MAAD,EAAuBvB,IAAvB;UACC8H,aAAa,GAAGD,SAAS,IAAI,MAAK7H,IAAI,CAAC+H,KAAL,CAAW,GAAX,CAAL,CAAnC;;UACMC,KAAK,GAAG,CACZhI,IADY,EAEZ2H,QAFY,EAGZC,QAAQ,GAAG1I,KAAH,GAAWqC,MAAM,CAAClB,QAAP,CAAgBnB,KAAhB,EAAuB4I,aAAvB,CAHP,CAAd;WAKOE,KAAK,CAAC7I,IAAN,CAAW,GAAX,CAAP;GAPF;;;;;;;;;;;;;;;;;;;;;;AA6BF,SAAgByH,OAAO1H,OAAY0I;SAC1BF,OAAO,CAAC,GAAD,EAAMxI,KAAN,EAAa0I,QAAb,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBf,YAAY3H,OAAY0I;SAC/BF,OAAO,CAAC,GAAD,EAAMxI,KAAN,EAAa0I,QAAb,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBd,eAAe5H,OAAY0I;SAClCF,OAAO,CAAC,IAAD,EAAOxI,KAAP,EAAc0I,QAAd,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBb,SAAS7H,OAAY0I;SAC5BF,OAAO,CAAC,GAAD,EAAMxI,KAAN,EAAa0I,QAAb,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBZ,YAAY9H,OAAY0I;SAC/BF,OAAO,CAAC,IAAD,EAAOxI,KAAP,EAAc0I,QAAd,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBX,WAAW/H,OAAe0I;SACjCF,OAAO,CAAC,aAAD,EAAgBxI,KAAhB,EAAuB0I,QAAvB,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBV,SAAShI,OAAe0I;SAC/BF,OAAO,CAAC,WAAD,EAAcxI,KAAd,EAAqB0I,QAArB,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBT,SAASjI,OAAe0I;SAC/BF,OAAO,CAAC,UAAD,EAAaxI,KAAb,EAAoB0I,QAApB,CAAd;;;;;;;;;;;;;;;;;;;;AAoBF,SAAgBR,QAAQlI,OAAc0I;SAC7BF,OAAO,CAAC,IAAD,EAAOxI,KAAP,EAAc0I,QAAd,CAAd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCF,SAAgBH,OAAOQ,KAAsBC,aAAuBN;MAC9DO,SAAS,GAAGF,GAAhB;;MACIA,GAAG,YAAYzJ,MAAnB,EAA2B;;;;IAIzB2J,SAAS,GAAGF,GAAG,CAAChI,QAAJ,GAAe7B,KAAf,CAAqB,gBAArB,EAAwC,CAAxC,CAAZ;;;SAEKsJ,OAAO,CAAC,IAAD,EAAOQ,WAAW,UAAUC,WAAV,GAAwBA,SAA1C,EAAqDP,QAArD,CAAd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCF,SAAgBL,QACd3H,OACAC,OACAuI,cAAc,GAAG,MACjBC,cAAc,GAAGD,gBACjB/C;QAEMiD,OAAO,GAAGF,cAAc,GAAG,IAAH,GAAU,GAAxC;QACMG,OAAO,GAAGF,cAAc,GAAG,IAAH,GAAU,GAAxC;SACO,CAAC9G,MAAD,EAAuBvB,IAAvB;UACC6H,SAAS,GAAG,YAAW7H,IAAX,CAAlB;;UACMwI,eAAe,GAAGd,OAAO,CAACY,OAAD,EAAU1I,KAAV,EAAiByF,SAAjB,UAAoCwC,WAApC,CAA/B;UACMY,eAAe,GAAGf,OAAO,CAACa,OAAD,EAAU1I,KAAV,EAAiBwF,SAAjB,UAAoCwC,WAApC,CAA/B;UAEMa,eAAe,GAAGF,eAAe,CAACjH,MAAD,EAASvB,IAAT,CAAvC;UACM2I,eAAe,GAAGF,eAAe,CAAClH,MAAD,EAASvB,IAAT,CAAvC;cACU0I,uBAAuBC,iBAAjC;GAPF;;;;;;;;;;;;;AAqBF,SAAgBnB;SACP,CAACjG,MAAD,EAASvB,IAAT,QAAqBA,cAA5B;;;;;;;;;;;;;AAaF,SAAgBqH,SAASuB;SAChB,CAACrH,MAAD,EAASvB,IAAT,QAAqBA,QAAQ4I,OAApC;;;;;;;;;;;;;AAaF,SAAgBtB;SACP,CAAC/F,MAAD,EAASvB,IAAT,eAA4BA,OAAnC;;;ACpVF,IAAkB6I,UAAlB;;AAAA,WAAkBA;EAChBA,kCAAA,SAAA;EACAA,gCAAA,OAAA;EACAA,iCAAA,QAAA;EACAA,iCAAA,QAAA;EACAA,iCAAA,QAAA;CALF,EAAkBA,UAAU,KAAVA,UAAU,KAAA,CAA5B;;AAQA,MAAsBC;AAItB,SAAgBC,mBACdxH,QACAyH,WACAhJ,OAAe;MAEX,YAAWgJ,SAAX,CAAJ,EAA2B;WAClBA,SAAS,CAACzH,MAAD,EAASvB,IAAT,CAAhB;;;QAEIiJ,aAAa,GAAG,MAAKjJ,IAAI,CAAC+H,KAAL,CAAW,GAAX,CAAL,CAAtB;;YACU/H,UAAUuB,MAAM,CAAClB,QAAP,CAAgB2I,SAAhB,EAA2BC,aAA3B,GAApB;;AAGF,SAAgBC,WACd3H,QACAK,YACAuH,aAAyBN,UAAU,CAACO,MACpCpJ,OAAe;MAEX,SAAQ4B,UAAR,CAAJ,EAAyB;WAChByH,SAAS,CAAC9H,MAAD,EAASK,UAAT,EAAqBuH,UAArB,EAAiCnJ,IAAjC,CAAhB;;;MAEE,eAAc4B,UAAd,CAAJ,EAA+B;WACtB0H,UAAU,CAAC/H,MAAD,EAASK,UAAT,EAAqBuH,UAArB,EAAiCnJ,IAAjC,CAAjB;;;MAEE4B,UAAU,YAAYkH,OAA1B,EAAmC;WAC1BlH,UAAU,CAAC2H,QAAX,CAAoBhI,MAApB,EAA4B4H,UAA5B,EAAwCnJ,IAAxC,CAAP;;;MAEE,UAAS4B,UAAT,CAAJ,EAA0B;WACjBmH,kBAAkB,CAACxH,MAAD,EAASkG,MAAM,CAAC7F,UAAD,CAAf,EAA6B5B,IAA7B,CAAzB;;;SAEK+I,kBAAkB,CAACxH,MAAD,EAASK,UAAT,EAAqB5B,IAArB,CAAzB;;AAGF,SAAgBwJ,WACdjI,QACAK,YACAuH,aAAyBN,UAAU,CAACO,MACpCpJ,OAAe;QAETyJ,MAAM,UAAUP,UAAU,CAAC3H,MAAD,EAASK,UAAT,EAAqBiH,UAAU,CAACa,GAAhC,EAAqC1J,IAArC,GAAhC;QACM2J,MAAM,GAAGR,UAAU,KAAKN,UAAU,CAACO,IAA1B,IAAkCD,UAAU,GAAGN,UAAU,CAACa,GAAzE;SACOC,MAAM,OAAOF,SAAP,GAAmBA,MAAhC;;AAGF,SAAgBJ,UACd9H,QACAK,YACAuH,aAAyBN,UAAU,CAACO,MACpCpJ,OAAe;;QAGT4J,aAAa,GAAGhI,UAAU,CAACtD,MAAX,GAAoB,CAApB,GAAwB6K,UAAxB,GAAqCN,UAAU,CAACgB,EAAtE;;QACMhH,OAAO,GAAG,KAAIjB,UAAJ,EAAgBoH,SAAS,IAAIE,UAAU,CAAC3H,MAAD,EAASyH,SAAT,EAAoBY,aAApB,EAAmC5J,IAAnC,CAAvC,CAAhB;;QAEMyJ,MAAM,GAAG5G,OAAO,CAAC1D,IAAR,CAAa,MAAb,CAAf;QACMwK,MAAM,GAAGR,UAAU,KAAKN,UAAU,CAACO,IAA1B,IAAkCD,UAAU,GAAGS,aAA9D;SACOD,MAAM,OAAOF,SAAP,GAAmBA,MAAhC;;AAGF,SAAgBK,WACdvI,QACAK,YACAuH,aAAyBN,UAAU,CAACO,MACpCpJ,OAAe;;QAGT4J,aAAa,GAAGhI,UAAU,CAACtD,MAAX,GAAoB,CAApB,GAAwB6K,UAAxB,GAAqCN,UAAU,CAACkB,GAAtE;;QACMlH,OAAO,GAAG,KAAIjB,UAAJ,EAAgBoH,SAAS,IAAIE,UAAU,CAAC3H,MAAD,EAASyH,SAAT,EAAoBY,aAApB,EAAmC5J,IAAnC,CAAvC,CAAhB;;QAEMyJ,MAAM,GAAG5G,OAAO,CAAC1D,IAAR,CAAa,OAAb,CAAf;QACMwK,MAAM,GAAGR,UAAU,KAAKN,UAAU,CAACO,IAA1B,IAAkCD,UAAU,GAAGS,aAA9D;SACOD,MAAM,OAAOF,SAAP,GAAmBA,MAAhC;;AAGF,SAAgBH,WACd/H,QACAK,YACAuH,aAAyBN,UAAU,CAACO,MACpCpJ,OAAe;;QAGTgK,UAAU,GAAGhK,IAAI,CAAC1B,MAAL,GAAc,CAAd,MAAqB0B,OAArB,GAA+B,EAAlD;;QAGM4J,aAAa,GAAG,MAAKhI,UAAL,EAAiBtD,MAAjB,GAA0B,CAA1B,GAA8B6K,UAA9B,GAA2CN,UAAU,CAACoB,GAA5E;;QACMpH,OAAO,GAAG,KAAIjB,UAAJ,EAAgB,CAACoH,SAAD,EAAY1J,GAAZ;WACvB4J,UAAU,CAAC3H,MAAD,EAASyH,SAAT,EAAoBY,aAApB,EAAmCI,UAAU,GAAG1K,GAAhD,CAAjB;GADc,CAAhB;;QAIMmK,MAAM,GAAG5G,OAAO,CAAC1D,IAAR,CAAa,OAAb,CAAf;QACMwK,MAAM,GAAGR,UAAU,KAAKN,UAAU,CAACO,IAA1B,IAAkCD,UAAU,GAAGS,aAA9D;SACOD,MAAM,OAAOF,SAAP,GAAmBA,MAAhC;;;MCzHWS,cAAc/I;EACzBpB,YAAmB6B;;mBAAA,GAAAA,UAAA;;;EAInBR,KAAK;oBACa8H,UAAU,CAAC,KAAKjI,YAAN,EAAoB,KAAKW,UAAzB,GAA1B;;;;;MCESuI,YAAYhJ;EAGvBpB,YAAYiE,QAAuC,GAAGoG;;;QAGhD,UAASpG,MAAT,CAAJ,EAAsB;WACfA,MAAL,GAAcA,MAAd;YACMzC,MAAM,GAAG6I,IAAI,CAAC,CAAD,CAAnB;;UACI,cAAa7I,MAAb,CAAJ,EAA0B;aACnB,MAAMjC,GAAX,IAAkBiC,MAAlB,EAA0B;cACpB8I,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BhJ,MAA3B,EAAmCjC,GAAnC,CAAJ,EAA6C;iBACtCe,QAAL,CAAckB,MAAM,CAACjC,GAAD,CAApB,EAA2BA,GAA3B;;;OAHN,MAMO,IAAI,CAAC,OAAMiC,MAAN,CAAL,EAAoB;cACnB,IAAIc,SAAJ,CAAc,iEAAd,CAAN;;KAVJ,MAYO,IAAI,SAAQ2B,MAAR,CAAJ,EAAqB;YACpBwG,WAAW,GAAG,KAAIJ,IAAJ,EAAU7J,KAAK,IAAI,KAAKF,QAAL,CAAcE,KAAd,CAAnB,CAApB;;WACKyD,MAAL,GAAc,SAAQ,KAAIA,MAAJ,EAAYwG,WAAZ,CAAR,EAAkCrL,IAAlC,CAAuC,EAAvC,CAAd;KAFK,MAGA;YACC,IAAIkD,SAAJ,CAAc,uCAAd,CAAN;;;;EAIJjB,KAAK;WACI,KAAK4C,MAAZ;;;;;MCnBSyG,gBAAgBtJ;EAG3BpB,YAAY2K,QAAkEvH;;UAEtEwH,SAAS,GAAGF,OAAO,CAACG,kBAAR,CAA2BzH,GAA3B,CAAlB;;QAEI,UAASuH,MAAT,CAAJ,EAAsB;WACfG,WAAL,GAAmB,CAAC;QAAEF,SAAF;QAAaG,KAAK,EAAEJ;OAArB,CAAnB;KADF,MAEO,IAAI,SAAQA,MAAR,CAAJ,EAAqB;WACrBG,WAAL,GAAmB,KAAIH,MAAJ,EAAaI,KAAD;YACzB,CAAC,SAAQA,KAAR,CAAL,EAAqB;iBACZ;YAAEA,KAAF;YAASH;WAAhB;;;cAEII,cAAc,GAAGD,KAAK,CAAC,CAAD,CAAL,GAAWL,OAAO,CAACG,kBAAR,CAA2BE,KAAK,CAAC,CAAD,CAAhC,CAAX,GAAkDH,SAAzE;eACO;UAAEG,KAAK,EAAEA,KAAK,CAAC,CAAD,CAAd;UAAmBH,SAAS,EAAEI;SAArC;OALiB,CAAnB;KADK,MAQA;WACAF,WAAL,GAAmB,KAAIH,MAAJ,EAAY,CAACK,cAAD,EAAiBD,KAAjB;eACtB;UAAEA,KAAF;UAASH,SAAS,EAAEF,OAAO,CAACG,kBAAR,CAA2BG,cAA3B;SAA3B;OADiB,CAAnB;;;;EAMJ3J,KAAK;UACGyJ,WAAW,GAAG,KAAI,KAAKA,WAAT,EAAsB,CAAC;MAAEC,KAAF;MAASH;KAAV;aACjC,SAAQG,SAASH,WAAjB,CAAP;KADkB,CAApB;;uBAGmBE,WAAW,CAAC1L,IAAZ,CAAiB,IAAjB,GAAnB;;;SAGayL,kBAAP,CAA0BzH,GAA1B;UACA6H,QAAQ,GAAG,OAAO7H,GAAP,KAAe,QAAf,GAA0BA,GAAG,CAAC8H,WAAJ,EAA1B,GAA8C9H,GAA/D;UACM+H,YAAY,GAAGF,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,YAApC,IAAoDA,QAAQ,KAAK,IAAtF;WACOE,YAAY,GAAG,MAAH,GAAY,EAA/B;;;;;MCnDSC,cAAc1H;EACzB1D,YACE2D;UAEMA,QAAN,EAAgB;MAAEnB,qBAAqB,EAAE;KAAzC;;;EAGFnB,KAAK;oBACa,MAAMA,KAAN,IAAhB;;;;;MCPSgK,gBAAgBjK;EAC3BpB,YAAsBiE;;eAAA,GAAAA,MAAA;IAEpBA,MAAM,CAACjD,eAAP,CAAuB,KAAKE,YAA5B;;;EAGFG,KAAK;uBACgB,KAAK4C,MAAL,CAAY5C,KAAZ,IAAnB;;;;;MCPSiK,iBAAiBlK;EAC5BpB,YAAsBiE;;eAAA,GAAAA,MAAA;IAEpBA,MAAM,CAACjD,eAAP,CAAuB,KAAKE,YAA5B;;;EAGFG,KAAK;wBACiB,KAAK4C,MAAL,CAAY5C,KAAZ,IAApB;;;;;MCGSkK,SAAS,GAAG;EAAEC,GAAF;EAAOC,EAAP;EAAWC,GAAX;EAAgBC;CAAlC;;;;;;;;;;;;;;;;;;;AAmBP,SAAgBH,IAAI3J;SACX,IAAI+J,QAAJ,CAAa/J,UAAb,CAAP;;AAGF,MAAa+J,iBAAiB7C;EAC5B/I,YAAsB6B;;mBAAA,GAAAA,UAAA;;;EAItB2H,QAAQ,CAAChI,MAAD,EAAuB4H,UAAU,GAAGN,UAAU,CAACO,IAA/C,EAAqDpJ,IAAI,GAAG,EAA5D;WACCsJ,UAAU,CAAC/H,MAAD,EAAS,KAAKK,UAAd,EAA0BuH,UAA1B,EAAsCnJ,IAAtC,CAAjB;;;;;;;;;;;;;;;;;;;;;;AAqBJ,SAAgBwL,GAAG5J;SACV,IAAIgK,OAAJ,CAAYhK,UAAZ,CAAP;;AAGF,MAAagK,gBAAgB9C;EAC3B/I,YAAsB6B;;mBAAA,GAAAA,UAAA;;;EAItB2H,QAAQ,CAAChI,MAAD,EAAuB4H,UAAU,GAAGN,UAAU,CAACO,IAA/C,EAAqDpJ,IAAI,GAAG,EAA5D;WACCqJ,SAAS,CAAC9H,MAAD,EAAS,KAAKK,UAAd,EAA0BuH,UAA1B,EAAsCnJ,IAAtC,CAAhB;;;;;;;;;;;;;;;;;;;;AAmBJ,SAAgByL,IAAI7J;SACX,IAAIiK,QAAJ,CAAajK,UAAb,CAAP;;AAGF,MAAaiK,iBAAiB/C;EAC5B/I,YAAsB6B;;mBAAA,GAAAA,UAAA;;;EAItB2H,QAAQ,CAAChI,MAAD,EAAuB4H,UAAU,GAAGN,UAAU,CAACO,IAA/C,EAAqDpJ,IAAI,GAAG,EAA5D;WACC8J,UAAU,CAACvI,MAAD,EAAS,KAAKK,UAAd,EAA0BuH,UAA1B,EAAsCnJ,IAAtC,CAAjB;;;;;;;;;;;;;;;;;;;;AAmBJ,SAAgB0L,IAAI9J;SACX,IAAIkK,QAAJ,CAAalK,UAAb,CAAP;;AAGF,MAAakK,iBAAiBhD;EAC5B/I,YAAsB6B;;mBAAA,GAAAA,UAAA;;;EAItB2H,QAAQ,CAAChI,MAAD,EAAuB4H,UAAU,GAAGN,UAAU,CAACO,IAA/C,EAAqDpJ,IAAI,GAAG,EAA5D;WACCwJ,UAAU,CAACjI,MAAD,EAAS,KAAKK,UAAd,EAA0BuH,UAA1B,EAAsCnJ,IAAtC,CAAjB;;;;;ACzFJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA,SAAgB4E,KACd5E,MACAR,QACAoC;SAEO,IAAIkB,WAAJ,CAAgB9C,IAAhB,EAAsBR,MAAtB,EAA8BoC,UAA9B,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEF,SAAgBnC,SACd0D,KACAnD,MACAR,QACAoC,YACAtD;SAEO,IAAI4E,eAAJ,CAAoBC,GAApB,EAAyBnD,IAAzB,EAA+BR,MAA/B,EAAuCoC,UAAvC,EAAmDtD,MAAnD,CAAP;;;MCvLWyN,cAAc5K;EACzBpB,YAAmBiM,MAAe;;YAAf,GAAAA,GAAA;;;EAInB5K,KAAK;mBACY,KAAK4K,GAAL,GAAW,MAAX,GAAoB,IAAnC;;;;;ACkBJ;;;;AAGA,MAAaC;EACXlM,YAAsBmM,OAAwCC;cAAxC,GAAAD,KAAA;gBAAwC,GAAAC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiD9DC,GAAG,CAACjG,UAAD,EAA4BtE,OAA5B;WACM,KAAKqK,KAAL,CAAW,KAAKG,IAAL,CAAU,IAAI9G,GAAJ,CAAQY,UAAR,EAAoBtE,OAApB,CAAV,CAAX,CAAP;;;;;;;;;;;;;;;;;;;;;;EAqBFyK,SAAS,CAAC9M,MAAD;WACA,KAAK0M,KAAL,CAAW,KAAKG,IAAL,CAAU,IAAI9G,GAAJ,CAAQ;MAAE/F;KAAV,CAAV,CAAX,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BF+M,SAAS,CAAC/G,MAAD,EAA0BG,KAA1B;WACA,KAAKuG,KAAL,CAAW,KAAKG,IAAL,CAAU,IAAI9G,GAAJ,CAAQ;MAAEC;KAAV,EAAoB;MAAEG;KAAtB,CAAV,CAAX,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2BF6G,YAAY,CAACnH,SAAD,EAAqDM,KAArD;WACH,KAAKuG,KAAL,CAAW,KAAKG,IAAL,CAAU,IAAI9G,GAAJ,CAAQ;MAAEF;KAAV,EAAuB;MAAEM;KAAzB,CAAV,CAAX,CAAP;;;EAGM0G,IAAI,CAACrI,MAAD;WACH,KAAKmI,OAAL,GAAe,IAAI,KAAKA,OAAT,CAAiBnI,MAAjB,CAAf,GAA0CA,MAAjD;;;;;;;;;;AASJ,MAAsByI,gBAAmBR;EACvClM;UACQ2M,CAAC,IAAI,KAAKC,mBAAL,CAAyBD,CAAzB,CAAX;;;;;;;;;;;;;;;;iBAkBF,GAAW,IAAIT,QAAJ,CAAgB,KAAKU,mBAAL,CAAyBC,IAAzB,CAA8B,IAA9B,CAAhB,EAAqDvB,QAArD,CAAX;;;;;;;;;;;;;;;;gBAiBA,GAAU,IAAIY,QAAJ,CAAgB,KAAKU,mBAAL,CAAyBC,IAAzB,CAA8B,IAA9B,CAAhB,EAAqDxB,OAArD,CAAV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyCAyB,MAAM,CAACnJ,QAAD,EAA8B7B,OAA9B;WACG,KAAK8K,mBAAL,CAAyB,IAAI1I,MAAJ,CAAWP,QAAX,EAAqB7B,OAArB,CAAzB,CAAP;;;;;;;EAMFiL,YAAY,CAACpJ,QAAD;WACH,KAAKmJ,MAAL,CAAYnJ,QAAZ,EAAsB;MAAEQ,MAAM,EAAE;KAAhC,CAAP;;;;;;;;EAOF6I,UAAU,CACR/M,IADQ,EAERR,MAFQ,EAGRoC,UAHQ,EAIRC,OAJQ;UAMFmC,MAAM,GAAG,IAAIC,MAAJ,CAAW,IAAInB,WAAJ,CAAgB9C,IAAhB,EAAsBR,MAAtB,EAA8BoC,UAA9B,CAAX,EAAsDC,OAAtD,CAAf;WACO,KAAK8K,mBAAL,CAAyB3I,MAAzB,CAAP;;;;;;;EAMFgJ,gBAAgB,CACdhN,IADc,EAEdR,MAFc,EAGdoC,UAHc;WAKP,KAAKmL,UAAL,CAAgB/M,IAAhB,EAAsBR,MAAtB,EAA8BoC,UAA9B,EAA0C;MAAEsC,MAAM,EAAE;KAApD,CAAP;;;;;;;;;;;;;;;;;;;;EAmBF+I,MAAM,CAAC7I,KAAD,EAAsBvC,OAAtB;WACG,KAAK8K,mBAAL,CAAyB,IAAIvH,MAAJ,CAAWhB,KAAX,EAAkBvC,OAAlB,CAAzB,CAAP;;;;;;;;;;;EAUFqL,YAAY,CAAC9I,KAAD,EAAsBvC,UAAyB,EAA/C;WACH,KAAK8K,mBAAL,CAAyB,IAAIvH,MAAJ,CAAWhB,KAAX,EAAkB,QAAOvC,OAAP,EAAgB;MAChEyD,MAAM,EAAE;KADwC,CAAlB,CAAzB,CAAP;;;;;;;;;;;EAYF6H,KAAK,CAAC3G,MAAD;WACI,KAAKmG,mBAAL,CAAyB,IAAIjG,KAAJ,CAAUF,MAAV,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyCFpI,KAAK,CAACsF,QAAD,EAA8B7B,OAA9B;WACI,KAAK8K,mBAAL,CAAyB,IAAI3G,KAAJ,CAAUtC,QAAV,EAAoB7B,OAApB,CAAzB,CAAP;;;;;;;;;;;;;EAYFuL,SAAS,CACPpN,IADO,EAEPR,MAFO,EAGPoC,UAHO;UAKDoC,MAAM,GAAG,IAAIgC,KAAJ,CAAU,IAAIlD,WAAJ,CAAgB9C,IAAhB,EAAsBR,MAAtB,EAA8BoC,UAA9B,CAAV,CAAf;WACO,KAAK+K,mBAAL,CAAyB3I,MAAzB,CAAP;;;;;;;;;;;EAUFqJ,aAAa,CAAC3J,QAAD,EAA8B7B,UAAwB,EAAtD;WACJ,KAAK8K,mBAAL,CAAyB,IAAI3G,KAAJ,CAAUtC,QAAV,EAAoB,QAAO7B,OAAP,EAAgB;MAClEoE,QAAQ,EAAE;KADwC,CAApB,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;EAqBFN,KAAK,CAACjC,QAAD;WACI,KAAKiJ,mBAAL,CAAyB,IAAIxB,KAAJ,CAAUzH,QAAV,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0DF4J,OAAO,CAAC5C,MAAD,EAAmEvH,GAAnE;WACE,KAAKwJ,mBAAL,CAAyB,IAAIlC,OAAJ,CAAYC,MAAZ,EAAoBvH,GAApB,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BFoK,GAAG,CAACvJ,MAAD,EAAwC,GAAGoG,IAA3C;WACM,KAAKuC,mBAAL,CAAyB,IAAIxC,GAAJ,CAAQnG,MAAR,EAAgB,GAAGoG,IAAnB,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmCFoD,MAAM,CAACrH,UAAD;WACG,KAAKwG,mBAAL,CAAyB,IAAIzG,MAAJ,CAAWC,UAAX,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;EAkBFsH,gBAAgB,CAACtH,UAAD;WACP,KAAKwG,mBAAL,CAAyB,IAAIzG,MAAJ,CAAW;MAAEC;KAAb,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;EAkBFuH,YAAY,CAAClO,MAAD;WACH,KAAKmN,mBAAL,CAAyB,IAAIzG,MAAJ,CAAW;MAAE1G;KAAb,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiEFmO,MAAM,CAACvJ,KAAD,EAAoBvC,OAApB;WACG,KAAK8K,mBAAL,CAAyB,IAAItG,MAAJ,CAAWjC,KAAX,EAAkBvC,OAAlB,CAAzB,CAAP;;;;;;;EAMF+L,cAAc,CAACxJ,KAAD;WACL,KAAKuJ,MAAL,CAAYvJ,KAAZ,EAAmB;MAAEkC,QAAQ,EAAE;KAA/B,CAAP;;;;;;;;;;;EAUFuH,IAAI,CAACrH,MAAD;WACK,KAAKmG,mBAAL,CAAyB,IAAIpG,IAAJ,CAASC,MAAT,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;EAoBFsH,KAAK,CAAC9B,GAAD;WACI,KAAKW,mBAAL,CAAyB,IAAIZ,KAAJ,CAAUC,GAAV,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;EAoBF+B,QAAQ;WACC,KAAKpB,mBAAL,CAAyB,IAAIZ,KAAJ,CAAU,IAAV,CAAzB,CAAP;;;;;;;;;;;;EAWFiC,MAAM,CAAChJ,IAAD,EAAchF,IAAd;WACG,KAAK2M,mBAAL,CAAyB,IAAIzH,MAAJ,CAAWF,IAAX,EAAiBhF,IAAjB,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkIFiO,KAAK,CAACrM,UAAD;WACI,KAAK+K,mBAAL,CAAyB,IAAIzC,KAAJ,CAAUtI,UAAV,CAAzB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6DFsM,IAAI,CAAC9J,KAAD;WACK,KAAKuI,mBAAL,CAAyB,IAAI1H,IAAJ,CAASb,KAAT,CAAzB,CAAP;;;;;MCn3BS+J;EACXC,gBAAgB,CAASC,OAAT;WACP,KAAIA,OAAJ,EAAaC,GAAG,IAAI,KAAKC,eAAL,CAAqBD,GAArB,CAApB,CAAP;;;EAGFC,eAAe,CAAUC,MAAV;WACN,WAAUA,MAAM,CAACC,QAAP,EAAV,EAAoC7J,IAAI,IAAI,KAAK8J,cAAL,CAAoB9J,IAApB,CAA5C,CAAP;;;EAGM8J,cAAc,CAACxP,KAAD;QAChB,KAAKyP,YAAL,CAAkBzP,KAAlB,CAAJ,EAA8B;aACrBA,KAAP;;;QAEE,SAAQA,KAAR,CAAJ,EAAoB;aACX,KAAIA,KAAJ,EAAW0P,CAAC,IAAI,KAAKF,cAAL,CAAoBE,CAApB,CAAhB,CAAP;;;QAEEC,KAAK,CAACC,KAAN,CAAY5P,KAAZ,CAAJ,EAAwB;aACf,KAAK6P,cAAL,CAAoB7P,KAApB,CAAP;;;QAEE,KAAK8P,MAAL,CAAY9P,KAAZ,CAAJ,EAAwB;aACf,KAAK+P,aAAL,CAAmB/P,KAAnB,CAAP;;;QAEE,KAAKgQ,UAAL,CAAgBhQ,KAAhB,CAAJ,EAA4B;aACnB,KAAKiQ,iBAAL,CAAuBjQ,KAAvB,CAAP;;;QAEE,OAAOA,KAAP,KAAiB,QAArB,EAA+B;aACtB,WAAUA,KAAV,EAAiB0P,CAAC,IAAI,KAAKF,cAAL,CAAoBE,CAApB,CAAtB,CAAP;;;WAEK,IAAP;;;EAGMD,YAAY,CAACzP,KAAD;UACZkQ,IAAI,GAAG,OAAOlQ,KAApB;WACOA,KAAK,IAAI,IAAT,IAAiBkQ,IAAI,KAAK,QAA1B,IAAsCA,IAAI,KAAK,SAA/C,IAA4DA,IAAI,KAAK,QAA5E;;;EAGMJ,MAAM,CAACpK,IAAD;WACLA,IAAI,KAAK,IAAT,IACF,OAAOA,IAAP,KAAgB,QADd,IAEF,CAAC,SAAQA,IAAR,CAFC,IAGFA,IAAI,CAACyK,QAHH,IAIFzK,IAAI,CAACpF,MAJH,IAKFoF,IAAI,CAACuB,UALV;;;EAQM8I,aAAa,CAACrK,IAAD;WACZ;MACLyK,QAAQ,EAAER,KAAK,CAACS,OAAN,CAAcrP,QAAd,CAAuB2E,IAAI,CAACyK,QAA5B,CADL;MAEL7P,MAAM,EAAEoF,IAAI,CAACpF,MAFR;MAGL2G,UAAU,EAAE,WAAUvB,IAAI,CAACuB,UAAf,EAA2B,KAAKuI,cAAL,CAAoB9B,IAApB,CAAyB,IAAzB,CAA3B;KAHd;;;EAOMsC,UAAU,CAACK,GAAD;WACTA,GAAG,CAACF,QAAJ,IAAgBE,GAAG,CAACH,IAApB,IAA4BG,GAAG,CAACpJ,UAAhC,IAA8CoJ,GAAG,CAACC,KAAlD,IAA2DD,GAAG,CAACE,GAAtE;;;EAGMN,iBAAiB,CAACI,GAAD;WAChB;MACLF,QAAQ,EAAER,KAAK,CAACS,OAAN,CAAcrP,QAAd,CAAuBsP,GAAG,CAACF,QAA3B,CADL;MAELG,KAAK,EAAEX,KAAK,CAACS,OAAN,CAAcrP,QAAd,CAAuBsP,GAAG,CAACC,KAA3B,CAFF;MAGLC,GAAG,EAAEZ,KAAK,CAACS,OAAN,CAAcrP,QAAd,CAAuBsP,GAAG,CAACE,GAA3B,CAHA;MAIL7G,KAAK,EAAE2G,GAAG,CAACH,IAJN;MAKLjJ,UAAU,EAAE,WAAUoJ,GAAG,CAACpJ,UAAd,EAA0B,KAAKuI,cAAL,CAAoB9B,IAApB,CAAyB,IAAzB,CAA1B;KALd;;;EASMmC,cAAc,CAACW,GAAD;QAChBb,KAAK,CAACS,OAAN,CAAcK,WAAd,CAA0BD,GAA1B,CAAJ,EAAoC;aAC3Bb,KAAK,CAACS,OAAN,CAAcM,QAAd,CAAuBF,GAAvB,CAAP;;;WAEKb,KAAK,CAACS,OAAN,CAAcrP,QAAd,CAAuByP,GAAvB,CAAP;;;;;MCrGSG,yBAAyB1O;EAAtCpB;;gBACY,GAAoB,EAApB;;;;;;;;EAMV+P,UAAU;WACD,KAAKC,OAAZ;;;;;;;;EAOFC,SAAS,CAAChM,MAAD;IACPA,MAAM,CAACjD,eAAP,CAAuB,KAAKE,YAA5B;SACK8O,OAAL,CAAalR,IAAb,CAAkBmF,MAAlB;;;;;;;EAMF5C,KAAK;cACO,KAAI,KAAK2O,OAAT,EAAkBE,CAAC,IAAIA,CAAC,CAAC7O,KAAF,EAAvB,EAAkCjC,IAAlC,CAAuC,IAAvC,IAAV;;;;;AC3BJ;AACA,MAUa+Q,cAAczD;;;;;;EAQzB1M,YAAsBoQ,aAAgC;;mBAAhC,GAAAA,UAAA;gBAPZ,GAAU,IAAIN,gBAAJ,EAAV;;;EAWAlD,mBAAmB,CAAC3I,MAAD;WACpB,KAAKgM,SAAL,CAAehM,MAAf,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqDFoM,GAAG;QACG,CAAC,KAAKD,UAAV,EAAsB;aACbE,UAAU,CAACC,MAAX,CACL,IAAIC,KAAJ,CAAU,mDAAV,CADK,CAAP;;;WAKK,KAAKJ,UAAL,CAAgBC,GAAhB,CAAuB,IAAvB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiDFI,MAAM;QACA,CAAC,KAAKL,UAAV,EAAsB;aACb,IAAIM,UAAJ,CAAgBC,UAAD;QACpBA,UAAU,CAACC,KAAX,CAAiB,IAAIJ,KAAJ,CAAU,mDAAV,CAAjB;OADK,CAAP;;;WAKK,KAAKJ,UAAL,CAAgBK,MAAhB,CAA0B,IAA1B,CAAP;;;;;;;;;;;;;;;;;;;EAkBFI,KAAK;WACI,KAAKR,GAAL,GAAcS,IAAd,CAAmBC,OAAO,IAAIA,OAAO,IAAIA,OAAO,CAACxS,MAAR,GAAiB,CAA5B,GAAgCwS,OAAO,CAAC,CAAD,CAAvC,GAA6C1O,SAA3E,CAAP;;;;;;;;;;;;;;;;;;;;;;;;EAwBFhB,KAAK;WACI,KAAK2O,OAAL,CAAa3O,KAAb,EAAP;;;;;;;;EAOFnB,QAAQ;WACC,KAAK8P,OAAL,CAAa9P,QAAb,EAAP;;;;;;;;EAOFoB,gBAAgB;WACP,KAAK0O,OAAL,CAAa1O,gBAAb,EAAP;;;;;;;;;;;;;;;;;;;;;;;;EAuBFG,WAAW;WACF,KAAKuO,OAAL,CAAavO,WAAb,EAAP;;;;;;;;EAOFsO,UAAU;WACD,KAAKC,OAAL,CAAaD,UAAb,EAAP;;;;;;;;;;;EAUFE,SAAS,CAAChM,MAAD;SACF+L,OAAL,CAAaC,SAAb,CAAuBhM,MAAvB;WACO,IAAP;;;;;AC7MJ,SAAS+M,aAAT,CAAuBC,WAAvB;SACS,cAAcA,WAAd,IAA6B,cAAcA,WAAlD;;;;;AAKF,MAAMC,cAAc,cAApB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,MAAaC,mBAAmBzE;;;;;;;;;;;;;;;;;;;;EA0B9B1M,YACYoR,KACVC,MACAvP,UAAiDgN,KAAK,CAACwC;;YAF7C,GAAAF,GAAA;oBAtBF,GAAc,IAAIhD,WAAJ,EAAd;SA4BHiD,IAAL,GAAYL,aAAa,CAACK,IAAD,CAAb,GACRvC,KAAK,CAACuC,IAAN,CAAWE,KAAX,CAAiBF,IAAI,CAACG,QAAtB,EAAgCH,IAAI,CAACI,QAArC,CADQ,GAERJ,IAFJ;UAIMK,iBAAiB,GAAGR,cAAc,CAACpP,OAAD,CAAd,GAA0BA,OAA1B,GACtBA,OAAO,CAAC4P,iBAAR,GAA4B5P,OAAO,CAAC4P,iBAApC,GAAwD5C,KAAK,CAACwC,MADlE;UAEMK,YAAY,GAAGT,cAAc,CAACpP,OAAD,CAAd,IAA2B,CAACA,OAAO,CAAC6P,YAApC,GACjB,EADiB,GACZ7P,OAAO,CAAC6P,YADjB;SAEK7P,OAAL,GAAe;MAAE4P,iBAAF;MAAqBC;KAApC;SACKL,MAAL,GAAcI,iBAAiB,CAAC,KAAKN,GAAN,EAAW,KAAKC,IAAhB,EAAsB,KAAKvP,OAAL,CAAa6P,YAAnC,CAA/B;SACKC,IAAL,GAAY,IAAZ;AACAC,AACD;;;;;;;EAMDC,KAAK;QACC,KAAKF,IAAT,EAAe;WACRN,MAAL,CAAYQ,KAAZ;WACKF,IAAL,GAAY,KAAZ;;;;;;;;;EAQJG,OAAO;QACD,KAAKH,IAAT,EAAe;aACN,KAAKN,MAAL,CAAYS,OAAZ,EAAP;;;WAEK,IAAP;;;;;;;;;;EASFxQ,KAAK;WACI,IAAI4O,KAAJ,CAAU,IAAV,CAAP;;;EAGQvD,mBAAmB,CAAC3I,MAAD;WACpB,KAAK1C,KAAL,GAAa0O,SAAb,CAAuBhM,MAAvB,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqDFoM,GAAG,CAAU9O,KAAV;QACG,CAAC,KAAKqQ,IAAV,EAAgB;aACPtB,UAAU,CAACC,MAAX,CACL,IAAIC,KAAJ,CAAU,2CAAV,CADK,CAAP;;;QAKEjP,KAAK,CAACwO,UAAN,GAAmBxR,MAAnB,KAA8B,CAAlC,EAAqC;aAC5B+R,UAAU,CAACC,MAAX,CACL,IAAIC,KAAJ,CAAU,qDAAV,CADK,CAAP;;;UAKIuB,OAAO,GAAG,KAAKA,OAAL,EAAhB;;QACI,CAACA,OAAL,EAAc;YACNvB,KAAK,CAAC,2CAAD,CAAX;;;UAGIwB,QAAQ,GAAGzQ,KAAK,CAACD,gBAAN,EAAjB;UACM2Q,MAAM,GAAGF,OAAO,CAAC1B,GAAR,CAAY2B,QAAQ,CAACzQ,KAArB,EAA4ByQ,QAAQ,CAACxQ,MAArC,CAAf;;WAGO8O,UAAU,CAAC4B,OAAX,CAAmBD,MAAnB,EACJnB,IADI,CACEmB,MAAD;MACJF,OAAO,CAACD,KAAR;aACO,KAAKK,WAAL,CAAiB9D,gBAAjB,CAAqC4D,MAAM,CAAC3D,OAA5C,CAAP;KAHG,EAKJ8D,KALI,CAKGxB,KAAD;MACLmB,OAAO,CAACD,KAAR;aACOO,OAAO,CAAC9B,MAAR,CAAeK,KAAf,CAAP;KAPG,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8EFH,MAAM,CAAUlP,KAAV;WACG,IAAImP,UAAJ,CAAgBC,UAAD;UAChB,CAAC,KAAKiB,IAAV,EAAgB;QACdjB,UAAU,CAACC,KAAX,CAAiB,IAAIJ,KAAJ,CAAU,2CAAV,CAAjB;;;;UAIEjP,KAAK,CAACwO,UAAN,GAAmBxR,MAAnB,KAA8B,CAAlC,EAAqC;QACnCoS,UAAU,CAACC,KAAX,CAAiBJ,KAAK,CAAC,qDAAD,CAAtB;;;;YAIIuB,OAAO,GAAG,KAAKA,OAAL,EAAhB;;UACI,CAACA,OAAL,EAAc;cACNvB,KAAK,CAAC,2CAAD,CAAX;;;;YAIIwB,QAAQ,GAAGzQ,KAAK,CAACD,gBAAN,EAAjB;YACM2Q,MAAM,GAAGF,OAAO,CAAC1B,GAAR,CAAY2B,QAAQ,CAACzQ,KAArB,EAA4ByQ,QAAQ,CAACxQ,MAArC,CAAf;;;MAIAyQ,MAAM,CAACK,SAAP,CAAiB;QACfC,MAAM,EAAG9D,MAAD;cACF,CAACkC,UAAU,CAAC6B,MAAhB,EAAwB;YACtB7B,UAAU,CAAC8B,IAAX,CAAgB,KAAKN,WAAL,CAAiB3D,eAAjB,CAAoCC,MAApC,CAAhB;;SAHW;QAMfiE,OAAO,EAAG9B,KAAD;UACPmB,OAAO,CAACD,KAAR;;cACI,CAACnB,UAAU,CAAC6B,MAAhB,EAAwB;YACtB7B,UAAU,CAACC,KAAX,CAAiBA,KAAjB;;SATW;QAYf+B,WAAW,EAAE;UACXZ,OAAO,CAACD,KAAR;;cACI,CAACnB,UAAU,CAAC6B,MAAhB,EAAwB;YACtB7B,UAAU,CAACiC,QAAX;;;OAfN;KAtBK,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}