{"version":3,"file":"cjs5.js","sources":["../src/utils.ts","../src/parameter-bag.ts","../src/parameter-container.ts","../src/clause.ts","../src/clauses/pattern.ts","../src/clauses/node-pattern.ts","../src/clauses/relation-pattern.ts","../src/clauses/pattern-clause.ts","../src/clauses/create.ts","../src/clauses/term-list-clause.ts","../src/clauses/with.ts","../src/clauses/unwind.ts","../src/clauses/delete.ts","../src/clauses/set.ts","../src/clauses/match.ts","../src/clauses/remove.ts","../src/clauses/return.ts","../src/clauses/skip.ts","../src/clauses/limit.ts","../src/clauses/where-comparators.ts","../src/clauses/where-utils.ts","../src/clauses/where.ts","../src/clauses/raw.ts","../src/clauses/order-by.ts","../src/clauses/merge.ts","../src/clauses/on-match.ts","../src/clauses/on-create.ts","../src/clauses/where-operators.ts","../src/clauses/index.ts","../src/clauses/union.ts","../src/builder.ts","../src/transformer.ts","../src/clause-collection.ts","../src/query.ts","../src/connection.ts"],"sourcesContent":["import {\n  camelCase,\n  castArray,\n  isArray,\n  isBoolean,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  map,\n  reduce,\n  Many,\n} from 'lodash';\n\n/**\n * Converts a string to camel case and ensures it is unique in the provided\n * list.\n * @param {string} str\n * @param {Array<string>} existing\n * @return {string}\n */\nexport function uniqueString(str: string, existing: string[]) {\n  let camelString = camelCase(str);\n\n  // Check if the string already has a number extension\n  let number = null;\n  const matches = camelString.match(/[0-9]+$/);\n  if (matches) {\n    number = +matches[0];\n    camelString = camelString.substr(0, camelString.length - matches[0].length);\n  }\n\n  // Compute all taken suffixes that are similar to the given string\n  const regex = new RegExp(`^${camelString}([0-9]*)$`);\n  const takenSuffixes = reduce(\n    existing,\n    (suffixes, existingString) => {\n      const matches = existingString.match(regex);\n      if (matches) {\n        const [, suffix] = matches;\n        suffixes.push(suffix ? +suffix : 1);\n      }\n      return suffixes;\n    },\n    [] as number[],\n  );\n\n  // If there was no suffix on the given string or it was already taken,\n  // compute the new suffix.\n  if (!number || takenSuffixes.indexOf(number) !== -1) {\n    number = Math.max(0, ...takenSuffixes) + 1;\n  }\n\n  // Append the suffix if it is not 1\n  return camelString + (number === 1 ? '' : number);\n}\n\n/**\n * Converts a Javascript value into a string suitable for a cypher query.\n * @param {object|Array|string|boolean|number} value\n * @return {string}\n */\nexport function stringifyValue(value: any): string {\n  if (isNumber(value) || isBoolean(value)) {\n    return `${value}`;\n  }\n  if (isString(value)) {\n    return `'${value}'`;\n  }\n  if (isArray(value)) {\n    const str = map(value, stringifyValue).join(', ');\n    return `[ ${str} ]`;\n  }\n  if (isObject(value)) {\n    const pairs = map(value, (el, key) => `${key}: ${stringifyValue(el)}`);\n    const str = pairs.join(', ');\n    return `{ ${str} }`;\n  }\n  return '';\n}\n\n/**\n * Converts labels into a string that can be put into a pattern.\n *\n * @param {string|array<string>} labels\n * @param relation When true, joins labels by a | instead of :\n * @return {string}\n */\nexport function stringifyLabels(labels: Many<string>, relation = false) {\n  if (labels.length === 0) {\n    return '';\n  }\n  return `:${castArray(labels).join(relation ? '|' : ':')}`;\n}\n\nexport type PathLength = '*'\n  | number\n  | [number | null | undefined]\n  | [number | null | undefined, number | null | undefined];\n\n/**\n * Converts a path length bounds into a string to put into a relationship.\n * @param  {Array<int>|int} bounds An array of bounds\n * @return {string}\n */\nexport function stringifyPathLength(bounds?: PathLength): string {\n  if (isNil(bounds)) {\n    return '';\n  }\n\n  if (bounds === '*') {\n    return '*';\n  }\n\n  if (isNumber(bounds)) {\n    return `*${bounds}`;\n  }\n\n  const lower = isNil(bounds[0]) ? '' : `${bounds[0]}`;\n  const upper = isNil(bounds[1]) ? '' : `${bounds[1]}`;\n  return lower || upper ? `*${lower}..${upper}` : '*';\n}\n","import { Dictionary, keys, mapValues } from 'lodash';\nimport { uniqueString } from './utils';\n\nexport class Parameter {\n  constructor(\n    public name: string,\n    public value: string,\n  ) { }\n\n  toString() {\n    return `$${this.name}`;\n  }\n}\n\nexport class ParameterBag {\n  protected parameterMap: Dictionary<Parameter> = {};\n\n  /**\n   * Constructs a unique name for this parameter bag.\n   * @return {string}\n   */\n  getName(name = 'p') {\n    return uniqueString(name, keys(this.parameterMap));\n  }\n\n  /**\n   * Adds a new parameter to this bag.\n   * @param {*} value\n   * @param {string|undefined} name\n   * @return {Parameter} Newly created parameter object.\n   */\n  addParam(value: any, name?: string) {\n    const actualName = this.getName(name);\n    const param = new Parameter(actualName, value);\n    this.parameterMap[actualName] = param;\n    return param;\n  }\n\n  /**\n   * Adds an existing parameter to this bag. The name may be changed if\n   * it is already taken, however, the Parameter object will not be recreated.\n   * @param {Parameter} param\n   * @return {Parameter}\n   */\n  addExistingParam(param: Parameter) {\n    param.name = this.getName(param.name);\n    this.parameterMap[param.name] = param;\n    return param;\n  }\n\n  /**\n   * Returns the params in a name: value object suitable for putting into a\n   * query object.\n   * @return {object}\n   */\n  getParams(): Dictionary<any> {\n    return mapValues(this.parameterMap, 'value');\n  }\n\n  /**\n   * Removes a parameter from the internal map.\n   * @param {string} name\n   */\n  deleteParam(name: string) {\n    delete this.parameterMap[name];\n  }\n\n  /**\n   * Copies all parameters from another bag into this bag.\n   */\n  importParams(other: ParameterBag) {\n    for (const key in other.parameterMap) {\n      this.addExistingParam(other.parameterMap[key]);\n    }\n  }\n\n  /**\n   * Returns a parameter with the given name.\n   */\n  getParam(name: string) {\n    return this.parameterMap[name];\n  }\n}\n","import { Parameter, ParameterBag } from './parameter-bag';\nimport { Dictionary } from 'lodash';\n\nexport class ParameterContainer {\n  protected parameterBag = new ParameterBag();\n\n  useParameterBag(newBag: ParameterBag) {\n    newBag.importParams(this.parameterBag);\n    this.parameterBag = newBag;\n  }\n\n  getParams(): Dictionary<any> {\n    return this.parameterBag.getParams();\n  }\n\n  /**\n   * Adds a new parameter to the bag.\n   * @param {*} value\n   * @param {string|undefined} name\n   * @return {Parameter} Newly created parameter object.\n   */\n  addParam(value: any, name?: string): Parameter {\n    return this.parameterBag.addParam(value, name);\n  }\n\n  getParameterBag() {\n    return this.parameterBag;\n  }\n}\n","import { stringifyValue } from './utils';\nimport { ParameterContainer } from './parameter-container';\nimport { Dictionary } from 'lodash';\n\nexport type QueryObject = {\n  query: string;\n  params: Dictionary<any>\n};\n\nexport abstract class Clause extends ParameterContainer {\n  /**\n   * Turns the clause into a query string.\n   * @return {string} Partial query string.\n   */\n  abstract build(): string;\n\n  /**\n   * Turns the clause into a query string.\n   * @return {string} Partial query string.\n   */\n  toString(): string {\n    return this.build();\n  }\n\n  /**\n   * Turns the clause into a query object.\n   * @return {object} Query object with two parameters: query and params.\n   */\n  buildQueryObject(): QueryObject {\n    return {\n      query: this.build(),\n      params: this.getParams(),\n    };\n  }\n\n  /**\n   * Turns the clause into a query string with parameters\n   * interpolated into the string. For debugging purposes only.\n   * @return {string}\n   */\n  interpolate(): string {\n    let query = this.build();\n    const params = this.getParams();\n    for (const name in params) {\n      const pattern = new RegExp(`\\\\$${name}(?![a-zA-Z0-9_])`, 'g');\n      query = query.replace(pattern, stringifyValue(params[name]));\n    }\n    return query;\n  }\n}\n","import {\n  mapValues, map, isEmpty, Dictionary, isArray, isString,\n  castArray, isObjectLike, isNil, Many,\n} from 'lodash';\nimport { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\nimport { stringifyLabels } from '../utils';\n\nexport abstract class Pattern extends Clause {\n  protected useExpandedConditions: boolean | undefined;\n  protected conditionParams: Dictionary<Parameter> | Parameter = {};\n  protected name: string;\n  protected labels: string[];\n  protected conditions: Dictionary<any>;\n\n  constructor(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n    protected options = { expanded: true },\n  ) {\n    super();\n    const isConditions = (a: any): a is Dictionary<any> => isObjectLike(a) && !isArray(a);\n    let tempName = name;\n    let tempLabels = labels;\n    let tempConditions = conditions;\n\n    if (isNil(tempConditions)) {\n      if (isConditions(tempLabels)) {\n        tempConditions = tempLabels;\n        tempLabels = undefined;\n      } else if (isNil(tempLabels) && isConditions(tempName)) {\n        tempConditions = tempName;\n        tempName = undefined;\n      } else {\n        tempConditions = {};\n      }\n    }\n\n    if (isNil(tempLabels)) {\n      if (isArray(tempName)) {\n        tempLabels = tempName;\n        tempName = undefined;\n      } else {\n        tempLabels = [];\n      }\n    }\n\n    if (isNil(tempName)) {\n      tempName = '';\n    }\n\n    if (!isString(tempName)) {\n      throw new TypeError('Name must be a string.');\n    }\n    if (!isString(tempLabels) && !isArray(tempLabels)) {\n      throw new TypeError('Labels must be a string or an array');\n    }\n    if (!isConditions(tempConditions)) {\n      throw new TypeError('Conditions must be an object.');\n    }\n\n    this.labels = castArray(tempLabels);\n    this.name = tempName;\n    this.conditions = tempConditions;\n    this.setExpandedConditions(options.expanded);\n  }\n\n  setExpandedConditions(expanded: boolean) {\n    if (this.useExpandedConditions !== expanded) {\n      this.useExpandedConditions = expanded;\n      this.rebindConditionParams();\n    }\n  }\n\n  rebindConditionParams() {\n    // Delete old bindings\n    if (this.conditionParams instanceof Parameter) {\n      this.parameterBag.deleteParam(this.conditionParams.name);\n    } else {\n      for (const key in this.conditionParams) {\n        this.parameterBag.deleteParam(this.conditionParams[key].name);\n      }\n    }\n\n    // Rebind params\n    if (!isEmpty(this.conditions)) {\n      if (this.useExpandedConditions) {\n        this.conditionParams = mapValues(this.conditions, (value, name) => {\n          return this.parameterBag.addParam(value, name);\n        });\n      } else {\n        this.conditionParams = this.parameterBag.addParam(this.conditions, 'conditions');\n      }\n    } else {\n      this.conditionParams = {};\n    }\n  }\n\n  getNameString() {\n    return this.name ? this.name : '';\n  }\n\n  getLabelsString(relation = false) {\n    return stringifyLabels(this.labels, relation);\n  }\n\n  getConditionsParamString() {\n    if (isEmpty(this.conditions)) {\n      return '';\n    }\n\n    if (this.useExpandedConditions) {\n      const strings = map(this.conditionParams, (param, name) => {\n        return `${name}: ${param}`;\n      });\n      return `{ ${strings.join(', ')} }`;\n    }\n    return this.conditionParams.toString();\n  }\n}\n","import { Dictionary, Many, trim } from 'lodash';\nimport { Pattern } from './pattern';\n\nexport class NodePattern extends Pattern {\n  constructor(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    super(name, labels, conditions);\n  }\n\n  build() {\n    let query = this.getNameString();\n    query += this.getLabelsString();\n    query += ` ${this.getConditionsParamString()}`;\n    return `(${trim(query)})`;\n  }\n}\n","import { Dictionary, trim, Many, isNil, isNumber, isArray, every } from 'lodash';\nimport { Pattern } from './pattern';\nimport { PathLength, stringifyPathLength } from '../utils';\n\nconst isPathLengthArray = (value: any) => (\n  isArray(value) && every(value, item => isNumber(item) || isNil(item)) && value.length > 0\n);\nconst isPathLength = (value: any): value is PathLength => (\n  value === '*' || isNumber(value) || isPathLengthArray(value)\n);\n\nexport type RelationDirection = 'in' | 'out' | 'either';\n\nexport class RelationPattern extends Pattern {\n  dir: RelationDirection;\n  length: PathLength | undefined;\n\n  constructor(\n    dir: RelationDirection,\n    name?: Many<string> | Dictionary<any> | PathLength,\n    labels?: Many<string> | Dictionary<any> | PathLength,\n    conditions?: Dictionary<any> | PathLength,\n    length?: PathLength,\n  ) {\n    let tempName = name;\n    let tempLabels = labels;\n    let tempConditions = conditions;\n    let tempLength = length;\n\n    if (isNil(tempLength)) {\n      if (isPathLength(tempConditions)) {\n        tempLength = tempConditions;\n        tempConditions = undefined;\n      } else if (isNil(tempConditions) && isPathLength(tempLabels)) {\n        tempLength = tempLabels;\n        tempLabels = undefined;\n      } else if (isNil(tempConditions) && isNil(tempLabels) && isPathLength(tempName)) {\n        tempLength = tempName;\n        tempName = undefined;\n      }\n    }\n\n    if (isPathLength(tempName) || isPathLength(tempLabels) || isPathLength(tempConditions)) {\n      throw new TypeError('Invalid argument combination.');\n    }\n\n    super(tempName, tempLabels, tempConditions);\n    this.dir = dir;\n    this.length = tempLength;\n  }\n\n  build() {\n    const name = this.getNameString();\n    const labels = this.getLabelsString(true);\n    const length = stringifyPathLength(this.length);\n    const conditions = this.getConditionsParamString();\n    const query = trim(`${name}${labels}${length} ${conditions}`);\n\n    const arrows: Record<'in' | 'out' | 'either', string[]> = {\n      in: ['<-', '-'],\n      out: ['-', '->'],\n      either: ['-', '-'],\n    };\n    return arrows[this.dir].join(query.length > 0 ? `[${query}]` : '');\n  }\n}\n","import { reduce, map, assign, castArray, isArray } from 'lodash';\nimport { Pattern } from './pattern';\nimport { Clause } from '../clause';\n\nexport interface PatternOptions {\n  useExpandedConditions?: boolean;\n}\n\nexport type PatternCollection = Pattern | Pattern[] | Pattern[][];\n\nexport class PatternClause extends Clause {\n  protected patterns: Pattern[][];\n\n  constructor(\n    patterns: PatternCollection,\n    options: PatternOptions = { useExpandedConditions: false },\n  ) {\n    super();\n    const defaultOptions = {\n      useExpandedConditions: true,\n    };\n    const { useExpandedConditions } = assign(defaultOptions, options);\n\n    // Ensure patterns is a two dimensional array.\n    const arr = castArray<Pattern | Pattern[]>(patterns);\n    this.patterns = (isArray(arr[0]) ? arr : [arr]) as Pattern[][];\n\n    // Add child patterns as clauses\n    this.patterns.forEach(arr => arr.forEach((pat) => {\n      pat.setExpandedConditions(useExpandedConditions);\n      pat.useParameterBag(this.parameterBag);\n    }));\n  }\n\n  build() {\n    const patternStrings = map(this.patterns, (pattern) => {\n      return reduce(pattern, (str, clause) => str + clause.build(), '');\n    });\n    return patternStrings.join(', ');\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport interface CreateOptions {\n  unique?: boolean;\n}\n\nexport class Create extends PatternClause {\n  constructor(patterns: PatternCollection, protected options: CreateOptions = {}) {\n    super(patterns, { useExpandedConditions: false });\n  }\n\n  build() {\n    const unique = this.options.unique ? ' UNIQUE' : '';\n    return `CREATE${unique} ${super.build()}`;\n  }\n}\n","import {\n  flatMapDeep,\n  map,\n  isPlainObject,\n  isString,\n  isArray,\n  castArray,\n  reduce,\n  Dictionary,\n  Many,\n} from 'lodash';\nimport { Clause } from '../clause';\n\nexport type Properties = (string | Dictionary<string>)[];\nexport type Term\n  = string\n  | Dictionary<string>\n  | Dictionary<Properties>;\n\nexport class TermListClause extends Clause {\n  protected terms: Term[];\n\n  /**\n   * Accepts:\n   *   node -> string\n   *   many nodes -> string[]\n   *   nodes with aliases -> Dictionary<string>\n   *   node properties -> Dictionary<string[]>\n   *   node properties with aliases -> Dictionary<Dictionary<string>[]>\n   * or an array of any combination\n   */\n  constructor(terms: Many<Term>) {\n    super();\n    this.terms = castArray(terms);\n  }\n\n  toString() {\n    return flatMapDeep(this.terms, term => this.stringifyTerm(term)).join(', ');\n  }\n\n  private stringifyTerm(term: Term): Many<string> {\n    // Just a node\n    if (isString(term)) {\n      return this.stringifyProperty(term);\n    }\n\n    // List of nodes\n    if (isArray(term)) {\n      return this.stringifyProperties(term);\n    }\n\n    // Node properties or aliases\n    if (isPlainObject(term)) {\n      return this.stringifyDictionary(term);\n    }\n\n    return '';\n  }\n\n  private stringifyProperty(prop: string, alias?: string, node?: string): string {\n    let prefix = node ? `${node}.` : '';\n    if (alias) {\n      prefix += `${alias} AS `;\n    }\n    return prefix + prop;\n  }\n\n  private stringifyProperties(props: Properties, alias?: string, node?: string): string[] {\n    const convertToString = (list: string[], prop: string | Dictionary<string>) => {\n      if (isString(prop)) {\n        // Single node property\n        list.push(this.stringifyProperty(prop, alias, node));\n      } else {\n        // Node properties with aliases\n        list.push(...map(prop, (name, alias) => this.stringifyProperty(name, alias, node)));\n      }\n      return list;\n    };\n    return reduce(props, convertToString, []);\n  }\n\n  private stringifyDictionary(node: Dictionary<string | Properties>): string[] {\n    return reduce(\n      node,\n      (list, prop, key) => {\n        if (isString(prop)) {\n          // Alias\n          list.push(this.stringifyProperty(prop, key));\n        } else {\n          // Node with properties\n          list.push(...this.stringifyProperties(prop, undefined, key));\n        }\n        return list;\n      },\n      [] as string[],\n    );\n  }\n\n  build() {\n    return this.toString();\n  }\n}\n","import { Many } from 'lodash';\nimport { Term, TermListClause } from './term-list-clause';\n\nexport class With extends TermListClause {\n  /**\n   * Creates a with clause\n   * @param  {string|object|array<string|object>} terms\n   */\n  constructor(terms: Many<Term>) {\n    super(terms);\n  }\n\n  build() {\n    return `WITH ${super.build()}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Unwind extends Clause {\n  protected listParam: Parameter;\n\n  constructor(\n    protected list: any[],\n    protected name: string,\n  ) {\n    super();\n    this.listParam = this.parameterBag.addParam(this.list, 'list');\n  }\n\n  build() {\n    return `UNWIND ${this.listParam} AS ${this.name}`;\n  }\n}\n","import { Many, castArray } from 'lodash';\nimport { Clause } from '../clause';\n\nexport interface DeleteOptions {\n  detach?: boolean;\n}\n\nexport class Delete extends Clause {\n  variables: string[];\n\n  constructor(\n    variables: Many<string>,\n    protected options: DeleteOptions = { },\n  ) {\n    super();\n    this.variables = castArray(variables);\n  }\n\n  build() {\n    const detach = this.options.detach ? 'DETACH ' : '';\n    return `${detach}DELETE ${this.variables.join(', ')}`;\n  }\n}\n","import {\n  concat, map, mapValues, castArray, Dictionary,\n  Many, isObject, isString,\n} from 'lodash';\nimport { Clause } from '../clause';\nimport { stringifyLabels } from '../utils';\nimport { Parameter } from '../parameter-bag';\n\nexport type SetProperties = {\n  labels?: Dictionary<Many<string>>,\n  values?: Dictionary<any>,\n  variables?: Dictionary<string | Dictionary<string>>,\n};\n\nexport interface SetOptions {\n  merge?: boolean;\n}\n\nexport class Set extends Clause {\n  protected labels: Dictionary<string[]>;\n  protected values: Dictionary<Parameter>;\n  protected variables: Dictionary<string | Dictionary<string>>;\n  protected merge: boolean;\n\n  protected makeLabelStatement = (labels: Many<string>, key: string) => {\n    return key + stringifyLabels(labels);\n  }\n\n  protected makeValueStatement = (value: any, key: string): string => {\n    const valueIsObject = value instanceof Parameter ? isObject(value.value) : isObject(value);\n    const op = this.merge && valueIsObject ? ' += ' : ' = ';\n    return key + op + value;\n  }\n\n  protected makeVariableStatement = (value: string | Dictionary<string>, key: string): string => {\n    const op = this.merge ? ' += ' : ' = ';\n    if (isString(value)) {\n      return key + op + value;\n    }\n    const operationStrings = map(value, (value, prop) => `${key}.${prop}${op}${value}`);\n    return operationStrings.join(', ');\n  }\n\n  constructor(\n    { labels, values, variables }: SetProperties,\n    options: SetOptions = {},\n  ) {\n    super();\n\n    this.labels = mapValues(labels, castArray);\n    this.values = mapValues(values, (value, name) => {\n      return this.parameterBag.addParam(value, name);\n    });\n    this.variables = variables || {};\n    this.merge = !!options.merge;\n  }\n\n  build() {\n    const labels = map(this.labels, this.makeLabelStatement);\n    const values = map(this.values, this.makeValueStatement);\n    const variables = map(this.variables, this.makeVariableStatement);\n    return `SET ${concat(labels, values, variables).join(', ')}`;\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport interface MatchOptions {\n  optional?: boolean;\n}\n\nexport class Match extends PatternClause {\n  constructor(\n    patterns: PatternCollection,\n    protected options: MatchOptions = { optional: false },\n  ) {\n    super(patterns, { useExpandedConditions: true });\n  }\n\n  build() {\n    let str = 'MATCH ';\n    if (this.options.optional) {\n      str = `OPTIONAL ${str}`;\n    }\n    return str + super.build();\n  }\n}\n","import { Clause } from '../clause';\nimport { Dictionary, Many, map, mapValues, flatMap, castArray } from 'lodash';\nimport { stringifyLabels } from '../utils';\n\nexport type RemoveProperties = {\n  labels?: Dictionary<Many<string>>;\n  properties?: Dictionary<Many<string>>;\n};\n\nexport class Remove extends Clause {\n  protected labels: Dictionary<string[]>;\n  protected properties: Dictionary<string[]>;\n\n  constructor({ labels = {}, properties = {} }: RemoveProperties) {\n    super();\n    this.labels = mapValues(labels, castArray);\n    this.properties = mapValues(properties, castArray);\n  }\n\n  build() {\n    const labels = map(this.labels, (labels, key) => key + stringifyLabels(labels));\n    const properties = flatMap(this.properties, (properties, key) => (\n      map(properties, property => `${key}.${property}`)\n    ));\n    return `REMOVE ${[...labels, ...properties].join(', ')}`;\n  }\n}\n","import { Many } from 'lodash';\nimport { Term, TermListClause } from './term-list-clause';\n\nexport interface ReturnOptions {\n  distinct?: boolean;\n}\n\nexport class Return extends TermListClause {\n  constructor(terms: Many<Term>, protected options: ReturnOptions = {}) {\n    super(terms);\n  }\n\n  build() {\n    const distinct = this.options.distinct ? ' DISTINCT' : '';\n    return `RETURN${distinct} ${super.build()}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Skip extends Clause {\n  protected amountParam: Parameter;\n\n  constructor(public amount: number) {\n    super();\n    this.amountParam = this.addParam(amount, 'skipCount');\n  }\n\n  build() {\n    return `SKIP ${this.amountParam}`;\n  }\n}\n","import { Clause } from '../clause';\nimport { Parameter } from '../parameter-bag';\n\nexport class Limit extends Clause {\n  protected amountParam: Parameter;\n\n  constructor(public amount: number) {\n    super();\n    this.amountParam = this.addParam(amount, 'limitCount');\n  }\n\n  build() {\n    return `LIMIT ${this.amountParam}`;\n  }\n}\n","import { last, capitalize } from 'lodash';\nimport { ParameterBag } from '../parameter-bag';\n\nexport const comparisions = {\n  equals,\n  greaterThan,\n  greaterEqualTo,\n  lessThan,\n  lessEqualTo,\n  startsWith,\n  endsWith,\n  contains,\n  inArray,\n  hasLabel,\n  exists,\n  between,\n  isNull,\n  regexp,\n};\n\nexport type Comparator = (params: ParameterBag, name: string) => string;\n\nfunction compare(operator: string, value: any, variable?: boolean, paramName?: string): Comparator {\n  return (params: ParameterBag, name: string): string => {\n    const baseParamName = paramName || last(name.split('.'));\n    const parts = [\n      name,\n      operator,\n      variable ? value : params.addParam(value, baseParamName),\n    ];\n    return parts.join(' ');\n  };\n}\n\n/**\n * Equals comparator for use in where clauses. This is the default so you will\n * probably never need to use this.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: equals(18) })\n * // WHERE age = 18\n *\n * query.where({ name: equals('clientName', true) })\n * // WHERE age = clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function equals(value: any, variable?: boolean) {\n  return compare('=', value, variable);\n}\n\n/**\n * Greater than comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: greaterThan(18) })\n * // WHERE age > 18\n *\n * query.where({ age: greaterThan('clientAge', true) })\n * // WHERE age > clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function greaterThan(value: any, variable?: boolean) {\n  return compare('>', value, variable);\n}\n\n/**\n * Greater or equal to comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: greaterEqualTo(18) })\n * // WHERE age >= 18\n *\n * query.where({ age: greaterEqualTo('clientAge', true) })\n * // WHERE age >= clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function greaterEqualTo(value: any, variable?: boolean) {\n  return compare('>=', value, variable);\n}\n\n/**\n * Less than comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: lessThan(18) })\n * // WHERE age < 18\n *\n * query.where({ age: lessThan('clientAge', true) })\n * // WHERE age < clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function lessThan(value: any, variable?: boolean) {\n  return compare('<', value, variable);\n}\n\n/**\n * Less or equal to comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: lessEqualTo(18) })\n * // WHERE age <= 18\n *\n * query.where({ age: lessEqualTo('clientAge', true) })\n * // WHERE age >= clientAge\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function lessEqualTo(value: any, variable?: boolean) {\n  return compare('<=', value, variable);\n}\n\n/**\n * Starts with comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: startsWith('steve') })\n * // WHERE name STARTS WITH 'steve'\n *\n * query.where({ name: startsWith('clientName', true) })\n * // WHERE name STARTS WITH clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function startsWith(value: string, variable?: boolean) {\n  return compare('STARTS WITH', value, variable);\n}\n\n/**\n * Ends with comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: endsWith('steve') })\n * // WHERE name ENDS WITH 'steve'\n *\n * query.where({ name: endsWith('clientName', true) })\n * // WHERE name ENDS WITH clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function endsWith(value: string, variable?: boolean) {\n  return compare('ENDS WITH', value, variable);\n}\n\n/**\n * Contains comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: contains('steve') })\n * // WHERE name CONTAINS 'steve'\n *\n * query.where({ name: contains('clientName', true) })\n * // WHERE name CONTAINS clientName\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function contains(value: string, variable?: boolean) {\n  return compare('CONTAINS', value, variable);\n}\n\n/**\n * In comparator for use in where clauses.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: inArray([ 'steve', 'william' ]) })\n * // WHERE name IN [ 'steve', 'william' ]\n *\n * query.where({ name: inArray('clientNames', true) })\n * // WHERE name IN clientNames\n * ```\n * @param value\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function inArray(value: any[], variable?: boolean) {\n  return compare('IN', value, variable);\n}\n\n/**\n * Regexp comparator for use in where clauses. Also accepts a case insensitive\n * to make it easier to add the `'(?i)'` flag to the start of your regexp.\n * If you are already using flags in your regexp, you should not set insensitive\n * to true because it will prepend `'(?i)'` which will make your regexp\n * malformed.\n *\n * For convenience you can also pass a Javascript RegExp object into this\n * comparator, which will then be converted into a string before it is\n * passed to cypher. *However*, beware that the cypher regexp syntax is\n * inherited from [java]{@link\n * https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html},\n * and may have slight differences to the Javascript syntax. For example,\n * Javascript RegExp flags will not be preserved when sent to cypher.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ name: regexp('s.*e') })\n * // WHERE name =~ 's.*e'\n *\n * query.where({ name: regexp('s.*e', true) })\n * // WHERE name =~ '(?i)s.*e'\n *\n * query.where({ name: regexp('clientPattern', false, true) })\n * // WHERE name =~ clientPattern\n * ```\n * @param exp\n * @param insensitive\n * @param {boolean} variable\n * @returns {Comparator}\n */\nexport function regexp(exp: string | RegExp, insensitive?: boolean, variable?: boolean) {\n  let stringExp = exp;\n  if (exp instanceof RegExp) {\n    // Convert regular expression to string and strip slashes and trailing flags.\n    // This regular expression will always match something so we can use the ! operator to ignore\n    // type errors.\n    stringExp = exp.toString().match(/\\/(.*)\\/[a-z]*/)![1];\n  }\n  return compare('=~', insensitive ? `(?i)${stringExp}` : stringExp, variable);\n}\n\n/**\n * Between comparator for use in where clauses. This comparator uses Neo4j's\n * shortcut comparison syntax: `18 <= age <= 65`.\n *\n * The `lower` and `upper` are the bounds of the comparison. You can use\n * `lowerInclusive` and `upperInclusive` to control whether it uses `<=` or `<`\n * for the comparison. They both default to `true`.\n *\n * If you pass only `lowerInclusive` then it will use that value for both.\n *\n * If you want to compare against a Neo4j variable you can set `variable` to\n * true and the value will be inserted literally into the query.\n *\n * ```\n * query.where({ age: between(18, 65) })\n * // WHERE age >= 18 AND age <= 65\n *\n * query.where({ age: between(18, 65, false) })\n * // WHERE age > 18 < AND age < 65\n *\n * query.where({ age: between(18, 65, true, false) })\n * // WHERE age >= 18 AND age < 65\n *\n * query.where({ age: between('lowerBound', 'upperBound', true, false, true) })\n * // WHERE age >= lowerBound AND age < upperBound\n * ```\n *\n * @param lower\n * @param upper\n * @param {boolean} lowerInclusive\n * @param {boolean} upperInclusive\n * @param {boolean} variables\n * @returns {Comparator}\n */\nexport function between(\n  lower: any,\n  upper: any,\n  lowerInclusive = true,\n  upperInclusive = lowerInclusive,\n  variables?: boolean,\n): Comparator {\n  const lowerOp = lowerInclusive ? '>=' : '>';\n  const upperOp = upperInclusive ? '<=' : '<';\n  return (params: ParameterBag, name) => {\n    const paramName = capitalize(name);\n    const lowerComparator = compare(lowerOp, lower, variables, `lower${paramName}`);\n    const upperComparator = compare(upperOp, upper, variables, `upper${paramName}`);\n\n    const lowerConstraint = lowerComparator(params, name);\n    const upperConstraint = upperComparator(params, name);\n    return `${lowerConstraint} AND ${upperConstraint}`;\n  };\n}\n\n/**\n * Is null comparator for use in where clauses. Note that this comparator does\n * not accept any arguments\n *\n * ```\n * query.where({ name: isNull() })\n * // WHERE name IS NULL\n * ```\n * @returns {Comparator}\n */\nexport function isNull(): Comparator {\n  return (params, name) => `${name} IS NULL`;\n}\n\n/**\n * Has label comparator for use in where clauses.\n *\n * ```\n * query.where({ person: hasLabel('Manager') })\n * // WHERE person:Manager\n * ```\n * @param {string} label\n * @returns {Comparator}\n */\nexport function hasLabel(label: string): Comparator {\n  return (params, name) => `${name}:${label}`;\n}\n\n/**\n * Exists comparator for use in where clauses. Note that this comparator does\n * not accept any arguments\n *\n * ```\n * query.where({ person: exists() })\n * // WHERE exists(person)\n * ```\n * @returns {Comparator}\n */\nexport function exists(): Comparator {\n  return (params, name) => `exists(${name})`;\n}\n","import {\n  Dictionary,\n  isPlainObject,\n  Many,\n  isArray,\n  map,\n  last,\n  keys,\n  isFunction,\n  isRegExp,\n} from 'lodash';\nimport { ParameterBag } from '../parameter-bag';\nimport { Comparator, regexp } from './where-comparators';\n\nexport type Condition = any | Comparator;\nexport type Conditions = Dictionary<Many<Condition>>;\nexport type NodeConditions = Dictionary<Many<Conditions>>;\nexport type AnyConditions = Many<NodeConditions | Conditions | Condition>;\nexport type AndConditions = NodeConditions | Conditions;\nexport type OrConditions = (NodeConditions | Conditions | Condition)[];\n\nexport const enum Precedence {\n  None,\n  Or,\n  Xor,\n  And,\n  Not,\n}\n\nexport abstract class WhereOp {\n  abstract evaluate(params: ParameterBag, precedence?: Precedence, name?: string): string;\n}\n\nexport function stringifyCondition(\n  params: ParameterBag,\n  condition: Condition,\n  name: string = '',\n): string {\n  if (isFunction(condition)) {\n    return condition(params, name);\n  }\n  const conditionName = last(name.split('.'));\n  return `${name} = ${params.addParam(condition, conditionName)}`;\n}\n\nexport function stringCons(\n  params: ParameterBag,\n  conditions: Many<NodeConditions | Conditions | Condition>,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  if (isArray(conditions)) {\n    return combineOr(params, conditions, precedence, name);\n  }\n  if (isPlainObject(conditions)) {\n    return combineAnd(params, conditions, precedence, name);\n  }\n  if (conditions instanceof WhereOp) {\n    return conditions.evaluate(params, precedence, name);\n  }\n  if (isRegExp(conditions)) {\n    return stringifyCondition(params, regexp(conditions), name);\n  }\n  return stringifyCondition(params, conditions, name);\n}\n\nexport function combineNot(\n  params: ParameterBag,\n  conditions: AnyConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  const string = `NOT ${stringCons(params, conditions, Precedence.Not, name)}`;\n  const braces = precedence !== Precedence.None && precedence > Precedence.Not;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineOr(\n  params: ParameterBag,\n  conditions: OrConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = conditions.length < 2 ? precedence : Precedence.Or;\n  const strings = map(conditions, condition => stringCons(params, condition, newPrecedence, name));\n\n  const string = strings.join(' OR ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineXor(\n  params: ParameterBag,\n  conditions: OrConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = conditions.length < 2 ? precedence : Precedence.Xor;\n  const strings = map(conditions, condition => stringCons(params, condition, newPrecedence, name));\n\n  const string = strings.join(' XOR ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n\nexport function combineAnd(\n  params: ParameterBag,\n  conditions: AndConditions,\n  precedence: Precedence = Precedence.None,\n  name: string = '',\n): string {\n  // Prepare name to be joined with the key of the object\n  const namePrefix = name.length > 0 ? `${name}.` : '';\n\n  // If this operator will not be used, precedence should not be altered\n  const newPrecedence = keys(conditions).length < 2 ? precedence : Precedence.And;\n  const strings = map(conditions, (condition, key) => {\n    return stringCons(params, condition, newPrecedence, namePrefix + key);\n  });\n\n  const string = strings.join(' AND ');\n  const braces = precedence !== Precedence.None && precedence > newPrecedence;\n  return braces ? `(${string})` : string;\n}\n","import { Clause } from '../clause';\nimport { AnyConditions, stringCons } from './where-utils';\n\nexport class Where extends Clause {\n  constructor(public conditions: AnyConditions) {\n    super();\n  }\n\n  build() {\n    return `WHERE ${stringCons(this.parameterBag, this.conditions)}`;\n  }\n}\n","import {\n  isString,\n  isArray,\n  isObjectLike,\n  map,\n  flatten,\n  zip,\n  isNil,\n} from 'lodash';\nimport { Clause } from '../clause';\n\nexport class Raw extends Clause {\n  clause: string;\n\n  constructor(clause: string | TemplateStringsArray, ...args: any[]) {\n    super();\n\n    if (isString(clause)) {\n      this.clause = clause;\n      const params = args[0];\n      if (isObjectLike(params)) {\n        for (const key in params) {\n          if (Object.hasOwnProperty.call(params, key)) {\n            this.addParam(params[key], key);\n          }\n        }\n      } else if (!isNil(params)) {\n        throw new TypeError('When passing a string clause to Raw, params should be an object');\n      }\n    } else if (isArray(clause)) {\n      const queryParams = map(args, param => this.addParam(param));\n      this.clause = flatten(zip(clause, queryParams)).join('');\n    } else {\n      throw new TypeError('Clause should be a string or an array');\n    }\n  }\n\n  build() {\n    return this.clause;\n  }\n}\n","import { map, isString, isArray, Dictionary, trim } from 'lodash';\nimport { Clause } from '../clause';\n\nexport type Direction = boolean\n  | 'DESC'\n  | 'desc'\n  | 'DESCENDING'\n  | 'descending'\n  | 'ASC'\n  | 'asc'\n  | 'ASCENDING'\n  | 'ascending'\n  | null\n  | undefined;\nexport type InternalDirection = 'DESC' | '';\nexport type OrderConstraint = [string, Direction] | [string];\nexport type InternalOrderConstraint = { field: string, direction: InternalDirection };\nexport type OrderConstraints = Dictionary<Direction>;\n\nexport class OrderBy extends Clause {\n  constraints: InternalOrderConstraint[];\n\n  constructor(fields: string | (string | OrderConstraint)[] | OrderConstraints, dir?: Direction) {\n    super();\n    const direction = OrderBy.normalizeDirection(dir);\n\n    if (isString(fields)) {\n      this.constraints = [{ direction, field: fields }];\n    } else if (isArray(fields)) {\n      this.constraints = map(fields, (field): InternalOrderConstraint => {\n        if (!isArray(field)) {\n          return { field, direction };\n        }\n        const fieldDirection = field[1] ? OrderBy.normalizeDirection(field[1]) : direction;\n        return { field: field[0], direction: fieldDirection };\n      });\n    } else {\n      this.constraints = map(fields, (fieldDirection, field) => {\n        return { field, direction: OrderBy.normalizeDirection(fieldDirection) };\n      });\n    }\n  }\n\n  build() {\n    const constraints = map(this.constraints, ({ field, direction }) => {\n      return trim(`${field} ${direction}`);\n    });\n    return `ORDER BY ${constraints.join(', ')}`;\n  }\n\n  private static normalizeDirection(dir?: Direction | string): InternalDirection {\n    const upperDir = typeof dir === 'string' ? dir.toUpperCase() : dir;\n    const isDescending = upperDir === 'DESC' || upperDir === 'DESCENDING' || upperDir === true;\n    return isDescending ? 'DESC' : '';\n  }\n}\n","import { PatternClause, PatternCollection } from './pattern-clause';\n\nexport class Merge extends PatternClause {\n  constructor(\n    patterns: PatternCollection,\n  ) {\n    super(patterns, { useExpandedConditions: true });\n  }\n\n  build() {\n    return `MERGE ${super.build()}`;\n  }\n}\n","import { Set } from './set';\nimport { Clause } from '../clause';\n\nexport class OnMatch extends Clause {\n  constructor(protected clause: Set) {\n    super();\n    clause.useParameterBag(this.parameterBag);\n  }\n\n  build() {\n    return `ON MATCH ${this.clause.build()}`;\n  }\n}\n","import { Set } from './set';\nimport { Clause } from '../clause';\n\nexport class OnCreate extends Clause {\n  constructor(protected clause: Set) {\n    super();\n    clause.useParameterBag(this.parameterBag);\n  }\n\n  build() {\n    return `ON CREATE ${this.clause.build()}`;\n  }\n}\n","import {\n  AndConditions,\n  AnyConditions,\n  combineAnd,\n  combineNot,\n  combineOr,\n  combineXor,\n  OrConditions,\n  Precedence,\n  WhereOp,\n} from './where-utils';\nimport { ParameterBag } from '../parameter-bag';\n\nexport const operators = { and, or, xor, not };\n\n/**\n * `AND` operator to use in where clauses. This is the default operator when\n * using conditions so you will probably never need to use this unless you'd\n * like to make it explicit.\n *\n * ```\n * query.where(and({\n *   'person.name': 'Steve',\n *   'person.age': greaterThan(18),\n * }));\n * // WHERE person.name = 'Steve' AND person.age > 18\n * ```\n * Note that this method only accepts a dictionary of conditions.\n *\n * @param {AndConditions} conditions\n * @returns {WhereAnd}\n */\nexport function and(conditions: AndConditions) {\n  return new WhereAnd(conditions);\n}\n\nexport class WhereAnd extends WhereOp {\n  constructor(protected conditions: AndConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineAnd(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `OR` operator to use in where clauses. This is the default operator when\n * supplying an array to where so you will probably never need to use this\n * unless you'd like to make it explicit.\n *\n * ```\n * query.where(or([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE person.name = 'Steve' OR person.age > 18\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereOr}\n */\nexport function or(conditions: OrConditions) {\n  return new WhereOr(conditions);\n}\n\nexport class WhereOr extends WhereOp {\n  constructor(protected conditions: OrConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineOr(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `XOR` operator to use in where clauses.\n *\n * ```\n * query.where(xor([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE person.name = 'Steve' XOR person.age > 18\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereXor}\n */\nexport function xor(conditions: OrConditions) {\n  return new WhereXor(conditions);\n}\n\nexport class WhereXor extends WhereOp {\n  constructor(protected conditions: OrConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineXor(params, this.conditions, precedence, name);\n  }\n}\n\n/**\n * `NOT` operator to use in where clauses.\n *\n * ```\n * query.where(not([\n *   { 'person.name': 'Steve' },\n *   { 'person.age': greaterThan(18) },\n * ]));\n * // WHERE NOT (person.name = 'Steve' AND person.age > 18)\n * ```\n * Note that this method only accepts an array of conditions.\n *\n * @param {OrConditions} conditions\n * @returns {WhereXor}\n */\nexport function not(conditions: AnyConditions) {\n  return new WhereNot(conditions);\n}\n\nexport class WhereNot extends WhereOp {\n  constructor(protected conditions: AnyConditions) {\n    super();\n  }\n\n  evaluate(params: ParameterBag, precedence = Precedence.None, name = '') {\n    return combineNot(params, this.conditions, precedence, name);\n  }\n}\n","import { Dictionary, Many } from 'lodash';\nimport { NodePattern } from './node-pattern';\nimport { RelationDirection, RelationPattern } from './relation-pattern';\nimport { PathLength } from '../utils';\n\nexport { Create } from './create';\nexport { NodePattern } from './node-pattern';\nexport { With } from './with';\nexport { Unwind } from './unwind';\nexport { Delete } from './delete';\nexport { Set } from './set';\nexport { RelationPattern } from './relation-pattern';\nexport { Match } from './match';\nexport { Remove } from './remove';\nexport { Return } from './return';\nexport { Skip } from './skip';\nexport { Limit } from './limit';\nexport { Where } from './where';\nexport { Raw } from './raw';\nexport { OrderBy } from './order-by';\nexport { Merge } from './merge';\nexport { OnMatch } from './on-match';\nexport { OnCreate } from './on-create';\nexport { and, or, xor, not, operators } from './where-operators';\nexport {\n  equals,\n  greaterThan,\n  greaterEqualTo,\n  lessThan,\n  lessEqualTo,\n  startsWith,\n  endsWith,\n  contains,\n  inArray,\n  hasLabel,\n  exists,\n  between,\n  isNull,\n  regexp,\n  comparisions,\n} from './where-comparators';\n\n/**\n * Creates a node pattern like `(parent:Person { name: 'Gwenn' })`.\n *\n * All of the arguments are optional and most of the time you can supply only\n * the ones you want, assuming you keep the order the same of course.\n *\n * Use the following signatures as a reference:\n *\n * ```typescript\n * node(conditions: Dictionary<any>)\n * node(labels: string[], conditions?: Dictionary<any>)\n * node(name: string, conditions?: Dictionary<any>)\n * node(name: string, labels?: string | string[], conditions?: Dictionary<any>)\n * ```\n * *Note that labels must be an array when it is the first argument.*\n *\n *\n *\n * Some examples\n *\n * ```typescript\n * node()\n * // ()\n *\n * node('parent')\n * // (parent)\n *\n * node('parent', 'Person')\n * // (parent:Person)\n *\n * node([ 'Person' ])\n * // (:Person)\n *\n * node('parent', [ 'Person', 'Adult' ])\n * // (parent:Person:Adult)\n *\n * node({ name: 'Gwenn' })\n * // ({ name: 'Gwenn' })\n *\n * node('parent', { name: 'Gwenn' })\n * // (parent { name: 'Gwenn' })\n *\n * node([ 'Person' ], { name: 'Gwenn' })\n * // (:Person { name: 'Gwenn' })\n *\n * node('parent', 'Person', { name: 'Gwenn' })\n * // (parent:Person { name: 'Gwenn' })\n * ```\n *\n * For more details on node patterns see the cypher\n * [docs]{@link\n * https://neo4j.com/docs/developer-manual/current/cypher/syntax/patterns/#cypher-pattern-node}\n *\n * @param {_.Many<string> | _.Dictionary<any>} name\n * @param {_.Many<string> | _.Dictionary<any>} labels\n * @param {_.Dictionary<any>} conditions A dictionary of conditions to attach\n * to the node. These are stored as parameters so there is no need to worry\n * about escaping.\n * @returns {NodePattern} An object representing the node pattern.\n */\nexport function node(\n  name?: Many<string> | Dictionary<any>,\n  labels?: Many<string> | Dictionary<any>,\n  conditions?: Dictionary<any>,\n) {\n  return new NodePattern(name, labels, conditions);\n}\n\n// Need to disable line length because there is a long link in the documentation\n/* tslint:disable:max-line-length */\n/**\n * Creates a relation pattern like `-[rel:FriendsWith { active: true }]->`.\n *\n * The only required argument is direction. All other arguments are optional and all combinations of\n * them are valid. The only exception is that when labels is the first argument after direction, it\n * must be an array, otherwise it will be interpreted as the relation name.\n *\n * Some examples\n *\n * ```typescript\n * relation('either')\n * //  --\n *\n * relation('out', 'rel')\n * //  -[rel]->\n *\n * relation('out', 'rel', 'FriendsWith')\n * //  -[rel:FriendsWith]->\n *\n * relation('in', [ 'FriendsWith', 'RelatedTo' ])\n * // <-[:FriendsWith|RelatedTo]-\n * // Note that this will match a relation with either the FriendsWith label or\n * // the RelatedTo label. You cannot use this syntax when creating relations.\n *\n * relation('in', [4, 10])\n * // <-[*4..10]-\n *\n * relation('in', { active: true })\n * // <-[{ active: true }]\n *\n * relation('in', 'rel', { active: true })\n * // <-[rel { active: true }]-\n *\n * relation('either', [ 'FriendsWith' ], { active: true })\n * //  -[:FriendsWith { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, 3)\n * //  -[rel:FriendsWith*3 { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, [ 3 ])\n * //  -[rel:FriendsWith*3.. { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, [ 3, 5 ])\n * //  -[rel:FriendsWith*3..5 { active: true }]-\n *\n * relation('either', 'rel', 'FriendsWith', { active: true }, '*')\n * //  -[rel:FriendsWith* { active: true }]-\n * ```\n *\n * For more details on relation patterns see the cypher\n * [docs]{@link\n * https://neo4j.com/docs/developer-manual/current/cypher/syntax/patterns/#cypher-pattern-relationship}.\n *\n * @param dir Direction of the relation. `in` means to the left, `out` means to\n * the right and `either` means no direction.\n * @param {_.Many<string> | _.Dictionary<any>} name\n * @param {_.Many<string> | _.Dictionary<any>} labels\n * @param {_.Dictionary<any>} conditions\n * @param length Length of the relation for flexible length paths. Can be the\n * string `'*'` to represent any length, a single number `3` to represent the\n * maximum length of the path, or an array of two numbers which represent the\n * minimum and maximum length of the path. When passing an array, the second\n * number is optional, see the examples above.\n * @returns {RelationPattern} An object representing the relation pattern.\n */\n/* tslint:disable:max-line-length */\nexport function relation(\n  dir: RelationDirection,\n  name?: Many<string> | Dictionary<any> | PathLength,\n  labels?: Many<string> | Dictionary<any> | PathLength,\n  conditions?: Dictionary<any> | PathLength,\n  length?: PathLength,\n) {\n  return new RelationPattern(dir, name, labels, conditions, length);\n}\n","import { Clause } from '../clause';\n\nexport class Union extends Clause {\n  constructor(public all: boolean = false) {\n    super();\n  }\n\n  build() {\n    return `UNION${this.all ? ' ALL' : ''}`;\n  }\n}\n","import { Dictionary, Many, assign } from 'lodash';\nimport {\n  Limit, Match, NodePattern, Skip, Where, Set, Create,\n  Return, With, Unwind, Delete, Raw, OrderBy, Merge, OnCreate, OnMatch,\n  Remove,\n} from './clauses';\nimport { CreateOptions } from './clauses/create';\nimport { DeleteOptions } from './clauses/delete';\nimport { MatchOptions } from './clauses/match';\nimport { Direction, OrderConstraint, OrderConstraints } from './clauses/order-by';\nimport { PatternCollection } from './clauses/pattern-clause';\nimport { SetOptions, SetProperties } from './clauses/set';\nimport { Term } from './clauses/term-list-clause';\nimport { AnyConditions } from './clauses/where-utils';\nimport { Clause } from './clause';\nimport { RemoveProperties } from './clauses/remove';\nimport { Union } from './clauses/union';\nimport { ReturnOptions } from './clauses/return';\n\n/**\n * @internal\n */\nexport interface WrapperClause {\n  new (clause: Set): Clause;\n}\n\n/**\n * @internal\n */\nexport class SetBlock<Q> {\n  constructor(protected chain: (clause: Clause) => Q, protected wrapper?: WrapperClause) { }\n\n  /**\n   * Adds a [set]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause to the query.\n   *\n   * `set` lets you updates a nodes labels and properties in one clause. Most of\n   * the time it will be easier to use one of the variants such as `setLabels`,\n   * `setValues` or `setVariables`.\n   *\n   * This function accepts three different kind of properties, each of which is\n   * described in more detail in the variants.\n   *\n   * ```\n   * query.set({\n   *   labels: {\n   *     sale: 'Active',\n   *   },\n   *   variables: {\n   *     sale: {\n   *       activatedAt: 'timestamp()',\n   *     },\n   *   },\n   *   values: {\n   *     sale: {\n   *       activatedBy: user.id,\n   *     },\n   *   },\n   * })\n   * // SET sale:Active, sale.activatedAt = timestamp(), sale.activatedBy = $userId\n   * ```\n   *\n   * `set` also accepts an options object which currently only contains a\n   * single setting: `override`. Override controls whether the `=` or `+=`\n   * operator is used in the set clause. `true` causes the existing object to be\n   * cleared and replaced by the new object. `false` on the other hand will\n   * merge the existing and new objects together, with new properties replacing\n   * the ones on the existing object.\n   * The default value of override is a little inconsistent and it will be\n   * improved in the next major version. If you don't pass any settings object,\n   * override will default to `true`. If you pass an options object without an\n   * `override` key, override will be `false`. In future versions, override will\n   * always default to `false` to be more consistent with `setVariables` and\n   * `setValues`.\n   *\n   * @param {SetProperties} properties\n   * @param {SetOptions} options\n   * @returns {Q}\n   */\n  set(properties: SetProperties, options?: SetOptions) {\n    return this.chain(this.wrap(new Set(properties, options)));\n  }\n\n  /**\n   * Adds labels to a node using a [set]{@link\n    * https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause.\n   *\n   * ```\n   * query.setLabels({\n   *   sale: 'Active',\n   * })\n   * // SET sale:Active\n   * ```\n   *\n   * `setLabels` accepts a dictionary where the keys are nodes to be updated\n   * and the value is a single label or an array of labels to add to the node.\n   *\n   * @param {_.Dictionary<_.Many<string>>} labels\n   * @returns {Q}\n   */\n  setLabels(labels: Dictionary<Many<string>>) {\n    return this.chain(this.wrap(new Set({ labels })));\n  }\n\n  /**\n   * Updates a node from parameters using a [set]{@link\n    * https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause. This function treats all values as parameters which is different to\n   * `setVariables` which assumes values are cypher variables.\n   *\n   * ```\n   * query.setValues({\n   *   'sale.activatedBy': user.id,\n   * })\n   * // SET sale.activatedBy += $userId\n   * ```\n   *\n   * `setValues` accepts a dictionary where the keys are nodes or property names\n   * to be updated.\n   *\n   * To use the `+=` operator to merge properties of a node, you can pass\n   * `true` to the merge option.\n   * ```\n   * query.setValues({\n   *   'sale': { active: true },\n   * }, true)\n   * // SET sale += $sale\n   * ```\n   */\n  setValues(values: Dictionary<any>, merge?: boolean) {\n    return this.chain(this.wrap(new Set({ values }, { merge })));\n  }\n\n  /**\n   * Updates a node from a variable that was previously declared in the query\n   * using a [set]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/set}\n   * clause. This function only accepts strings as its values which are not\n   * escaped in any way so beware. If you want to store some user supplied\n   * information in the database, `setValues` is the function you want.\n   *\n   * ```\n   * query.setVariables({\n   *   'sale.activatedAt': 'timestamp()',\n   * })\n   * // SET sale.activatedAt = timestamp()\n   * ```\n   * Note how values are inserted into the query, as is.\n   *\n   * To use the `+=` operator to merge properties of a node, you can pass\n   * `true` to the merge option.\n   * ```\n   * query.setVariables({\n   *   'sale': 'newSaleDetails'\n   * }, true)\n   * // SET sale += newSaleDetails\n   * ```\n   */\n  setVariables(variables: Dictionary<string | Dictionary<string>>, merge?: boolean) {\n    return this.chain(this.wrap(new Set({ variables }, { merge })));\n  }\n\n  private wrap(clause: Set): Clause {\n    return this.wrapper ? new this.wrapper(clause) : clause;\n  }\n}\n\n/**\n * Root class for all query chains, namely the {@link Connection} and\n * {@link Query} classes.\n * @internal\n */\nexport abstract class Builder<Q> extends SetBlock<Q> {\n  protected constructor() {\n    super(c => this.continueChainClause(c));\n  }\n\n  /**\n   * Used to add an `ON CREATE` clause to the query. Any following query will be prefixed with\n   * `ON CREATE`.\n   *\n   * Example:\n   * ```javascript\n   * query.onCreate.setLabels({ node: 'Active' });\n   * // ON CREATE SET node:Active\n\n   * query.onCreate.setVariables({ 'node.createdAt': 'timestamp()' });\n   * // ON CREATE SET node.createdAt = timestamp()\n   * ````\n   *\n   * The only methods that are available after `onCreate` are the set family of clauses.\n   */\n  onCreate = new SetBlock<Q>(this.continueChainClause.bind(this), OnCreate);\n\n  /**\n   * Used to add an `ON MATCH` clause to the query. Any following query will be prefixed with\n   * `ON MATCH`.\n   *\n   * Example:\n   * ```javascript\n   * query.onMatch.setLabels({ node: 'Active' });\n   * // ON MATCH SET node:Active\n\n   * query.onMatch.setVariables({ 'node.updatedAt': 'timestamp()' });\n   * // ON MATCH SET node.createdAt = timestamp()\n   * ````\n   *\n   * The only methods that are available after `onMatch` are the set family of clauses.\n   */\n  onMatch = new SetBlock<Q>(this.continueChainClause.bind(this), OnMatch);\n\n  /**\n   * Adds a clause to the current chain and returns something that can be\n   * chained with more clauses.\n   * @param {Clause} clause\n   * @returns {Q}\n   */\n  protected abstract continueChainClause(clause: Clause): Q;\n\n  /**\n   * Adds a [create]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/create}\n   * clause to the query.\n   *\n   * Create accepts a single pattern, a list of patterns or a list of a list of\n   * patterns. Each pattern represents a single part of a cypher pattern. For\n   * example: `(people:Person { age: 30 })` would be a node pattern and\n   * `-[:FriendsWith]->` would be a relationship pattern.\n   *\n   * If an array of patterns is provided, they are joined together to form a\n   * composite pattern. For example:\n   * ```javascript\n   * query.create([\n   *   node('people', 'Person', { age: 30 }),\n   *   relation('out', '', 'FriendsWith'),\n   *   node('friend', 'Friend'),\n   * ])\n   * ```\n   *\n   * Would equate to the cypher pattern\n   * ```\n   * CREATE (people:Person { age: 30 })-[:FriendsWith]->(friend:Friend)\n   * ```\n   *\n   * The create method also accepts a `unique` option which will cause a `CREATE UNIQUE` clause to\n   * be emitted instead.\n   * ```javascript\n   * query.create([node('people', 'Person', { age: 30 })], { unique: true });\n   * // CREATE UNIQUE (people:Person { age: 30 })\n   * ```\n   */\n  create(patterns: PatternCollection, options?: CreateOptions) {\n    return this.continueChainClause(new Create(patterns, options));\n  }\n\n  /**\n   * Shorthand for `create(patterns, { unique: true })`\n   */\n  createUnique(patterns: PatternCollection) {\n    return this.create(patterns, { unique: true });\n  }\n\n  /**\n   * Shorthand for `create(node(name, labels, conditions), options)`. For more details\n   * the arguments see @{link node}.\n   */\n  createNode(\n    name: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n    options?: CreateOptions,\n  ) {\n    const clause = new Create(new NodePattern(name, labels, conditions), options);\n    return this.continueChainClause(clause);\n  }\n\n  /**\n   * Shorthand for `createNode(name, labels, conditions, { unique: true })`\n   */\n  createUniqueNode(\n    name: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    return this.createNode(name, labels, conditions, { unique: true });\n  }\n\n  /**\n   * Adds a [delete]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/delete}\n   * clause to the query.\n   *\n   * Delete accepts a single string or an array of them and all of them are\n   * joined together with commas. *Note that these strings are not escaped or\n   * passed to Neo4j using parameters, therefore you should not pass user\n   * input into this clause without escaping it first*.\n   *\n   * You can set `detach: true` in the options to make it a `DETACH DELETE`\n   * clause.\n   *\n   * @param {_.Many<string>} terms\n   * @param {DeleteOptions} options\n   * @returns {Q}\n   */\n  delete(terms: Many<string>, options?: DeleteOptions) {\n    return this.continueChainClause(new Delete(terms, options));\n  }\n\n  /**\n   * Shorthand for `delete(terms, { detach: true })`.\n   *\n   * @param {_.Many<string>} terms\n   * @param {DeleteOptions} options\n   * @returns {Q}\n   */\n  detachDelete(terms: Many<string>, options: DeleteOptions = {}) {\n    return this.continueChainClause(new Delete(terms, assign(options, {\n      detach: true,\n    })));\n  }\n\n  /**\n   * Adds a [limit]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/limit}\n   * clause to the query.\n   *\n   * @param {string | number} amount\n   * @returns {Q}\n   */\n  limit(amount: number) {\n    return this.continueChainClause(new Limit(amount));\n  }\n\n  /**\n   * Adds a [match]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/match}\n   * clause to the query.\n   *\n   * Match accepts a single pattern, a list of patterns or a list of a list of\n   * patterns. Each pattern represents a single part of a cypher pattern. For\n   * example: `(people:Person { age: 30 })` would be a node pattern and\n   * `-[:FriendsWith]->` would be a relationship pattern.\n   *\n   * If an array of patterns is provided, they are joined together to form a\n   * composite pattern. For example:\n   * ```javascript\n   * query.match([\n   *   node('people', 'Person', { age: 30 }),\n   *   relation('out', '', 'FriendsWith'),\n   *   node('friends'),\n   * ])\n   * ```\n   *\n   * Would equate to the cypher pattern\n   * ```\n   * MATCH (people:Person { age: 30 })-[:FriendsWith]->(friends)\n   * ```\n   *\n   * If an array of an array of patterns is provided each array is joined\n   * together like above, and then each composite pattern is joined with a comma\n   * to allow matching of multiple distinct patterns. Note: matching many\n   * distinct patterns will produce a cross product of the results as noted in\n   * the [cypher docs]{@link\n   * https://neo4j.com/developer/kb/cross-product-cypher-queries-will-not-perform-well/}.\n   *\n   * You can also provide `optional: true` in the options to create and\n   * `OPTIONAL MATCH` clause.\n   *\n   * @param {PatternCollection} patterns List of patterns to be matched.\n   * @param {MatchOptions} options\n   * @returns {Q}\n   */\n  match(patterns: PatternCollection, options?: MatchOptions) {\n    return this.continueChainClause(new Match(patterns, options));\n  }\n\n  /**\n   * Shorthand for `match(node(name, labels, conditions))`. For more details on\n   * the arguments see {@link node}.\n   *\n   * @param {_.Many<string> | _.Dictionary<any>} name\n   * @param {_.Many<string> | _.Dictionary<any>} labels\n   * @param {_.Dictionary<any>} conditions\n   * @returns {Q}\n   */\n  matchNode(\n    name?: Many<string> | Dictionary<any>,\n    labels?: Many<string> | Dictionary<any>,\n    conditions?: Dictionary<any>,\n  ) {\n    const clause = new Match(new NodePattern(name, labels, conditions));\n    return this.continueChainClause(clause);\n  }\n\n  /**\n   * Shorthand for `match(patterns, { optional: true })`.\n   *\n   * @param {PatternCollection} patterns\n   * @param {MatchOptions} options\n   * @returns {Q}\n   */\n  optionalMatch(patterns: PatternCollection, options: MatchOptions = {}) {\n    return this.continueChainClause(new Match(patterns, assign(options, {\n      optional: true,\n    })));\n  }\n\n  /**\n   * Adds a [merge]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/merge/}\n   * clause to the query. It accepts the same parameters as `match` and `create` so refer to them\n   * for more information.\n   *\n   * ```javascript\n   * query.merge([\n   *   node('user', 'User', { id: 1 }),\n   *   relation('out', 'rel', 'OwnsProject'),\n   *   node('project', 'Project', { id: 20 }),\n   * ])\n   * .onMatch.setVariables({ 'rel.updatedAt': `timestamp` });\n   * // MERGE (user:User { id: 1 })-[rel:OwnsProject]->(project:Project { id: 20 })\n   * // ON MATCH SET rel.updatedAt = timestamp()\n   * ```\n   */\n  merge(patterns: PatternCollection) {\n    return this.continueChainClause(new Merge(patterns));\n  }\n\n  /**\n   * Adds an [order by]{@link\n   * https://neo4j.com/docs/developer-manual/current/cypher/clauses/order-by}\n   * to the query.\n   *\n   * Pass a single string or an array of strings to order by.\n   * ```javascript\n   * query.orderBy([\n   *   'name',\n   *   'occupation',\n   * ])\n   * // ORDER BY name, occupation\n   * ```\n   *\n   * You can control the sort direction by adding a direction to each property.\n   * ```javascript\n   * query.orderBy([\n   *   ['name', 'DESC'],\n   *   'occupation', // Same as ['occupation', 'ASC']\n   * ])\n   * // ORDER BY name DESC, occupation\n   * ```\n   *\n   * The second parameter is the default search direction for all properties that\n   * don't have a direction specified. So the above query could instead be\n   * written as:\n   * ```javascript\n   * query.orderBy([\n   *   'name',\n   *   ['occupation', 'ASC']\n   * ], 'DESC')\n   * // ORDER BY name DESC, occupation\n   * ```\n   *\n   * It is also acceptable to pass an object where each key is the\n   * property and the value is a direction. Eg:\n   * ```javascript\n   * query.orderBy({\n   *   name: 'DESC',\n   *   occupation: 'ASC',\n   * })\n   * ```\n   * However, the underlying iteration order is not always guaranteed and\n   * it may cause subtle bugs in your code. It is still accepted but it\n   * is recommended that you use the array syntax above.\n   *\n   * Valid values for directions are `DESC`, `DESCENDING`, `ASC`, `ASCENDING`.\n   * `true` and `false` are also accepted (`true` being the same as `DESC` and\n   * `false` the same as `ASC`), however they should be avoided as they are\n   * quite ambiguous. Directions always default to `ASC` as it does in cypher.\n   *\n   * @param {_.Many<string> | OrderConstraints} fields\n   * @param {Direction} dir\n   * @returns {Q}\n   */\n  orderBy(fields: string | (string | OrderConstraint)[] | OrderConstraints, dir?: Direction) {\n    return this.continueChainClause(new OrderBy(fields, dir));\n  }\n\n  /**\n   * Adds a clause to the query as is. You can also provide an object of params\n   * as well.\n   *\n   * ```javascript\n   * query.raw('MATCH (:Event { date: $date }', { date: '2017-01-01' })\n   * ```\n   *\n   * `raw` can also be used as a template tag\n   *\n   * ```javascript\n   * query.matchNode('event', 'Event', { id: 1 })\n   *  .raw`SET event.finishedAt = ${Date.now()}`\n   * ```\n   *\n   * But note that using template parameters where they are not supported in a query will produce\n   * an malformed query.\n   *\n   * ```javascript\n   * query.raw`SET node.${property} = 'value'`\n   * // Invalid query:\n   * // SET node.$param1 = 'value'\n   * ```\n   *\n   * @param {string} clause\n   * @param args\n   * @returns {Q}\n   */\n  raw(clause: string | TemplateStringsArray, ...args: any[]) {\n    return this.continueChainClause(new Raw(clause, ...args));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass objects containing the list of properties and labels to remove from a node. Each key in an\n   * object is the name of a node and the values are the names of the labels and properties to\n   * remove. The values of each object can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   labels: {\n   *     coupon: 'Active',\n   *   },\n   *   properties: {\n   *     customer: ['inactive', 'new'],\n   *   },\n   * });\n   * // REMOVE coupon:Active, customer.inactive, customer.new\n   * ```\n   *\n   * Both labels and properties objects are optional, but you must provide at least one of them for\n   * the query to be syntatically valid.\n   * ```\n   * query.remove({\n   *\n   * });\n   * // Invalid query:\n   * // REMOVE\n   * ```\n   *\n   * If you only need to remove labels *or* properties, you may find `removeProperties` or\n   * `removeLabels` more convenient.\n   */\n  remove(properties: RemoveProperties) {\n    return this.continueChainClause(new Remove(properties));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass an object containing the list of properties to remove from a node. Each key in the\n   * object is the name of a node and the values are the names of the properties to remove. The\n   * values can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   customer: ['inactive', 'new'],\n   *   coupon: 'available',\n   * });\n   * // REMOVE customer.inactive, customer.new, coupon.available\n   * ```\n   */\n  removeProperties(properties: Dictionary<Many<string>>) {\n    return this.continueChainClause(new Remove({ properties }));\n  }\n\n  /**\n   * Adds a [remove]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/remove/}\n   * clause to the query.\n   *\n   * Pass an object containing the list of labels to remove from a node. Each key in the\n   * object is the name of a node and the values are the names of the labels to remove. The\n   * values can be either a single string, or an array of strings.\n   * ```javascript\n   * query.remove({\n   *   customer: ['Inactive', 'New'],\n   *   coupon: 'Available',\n   * });\n   * // REMOVE customer:Inactive, customer:New, coupon:Available\n   * ```\n   */\n  removeLabels(labels: Dictionary<Many<string>>) {\n    return this.continueChainClause(new Remove({ labels }));\n  }\n\n  /**\n   * Adds a [return]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/return}\n   * clause to the query.\n   *\n   * There are many different ways to pass arguments to `return` so each is\n   * documented in turn below.\n   *\n   * A single string:\n   * ```javascript\n   * query.return('people')\n   * // RETURN people\n   * ```\n   *\n   * An array of strings to return multiple variables:\n   * ```javascript\n   * query.return([ 'people', 'pets' ])\n   * // RETURN people, pets\n   * ```\n   *\n   * A single object to rename variables:\n   * ```javascript\n   * query.return({ people: 'employees' })\n   * // RETURN people AS employees\n   * ```\n   *\n   * A single object with an array for each value:\n   * ```javascript\n   * query.return({\n   *   people: [ 'name', 'age' ],\n   *   pets: [ 'name', 'breed' ],\n   * })\n   * // RETURN people.name, people.age, pets.name, pets.breed\n   * ```\n   * This gives you a shortcut to specifying many node properties. You can also\n   * rename each property by adding an object inside the array or by providing\n   * an object as the value:\n   * ```javascript\n   * query.return({\n   *   people: [{ name: 'personName' }, 'age' ],\n   * })\n   * // RETURN people.name as personName, people.age\n   * ```\n   * or\n   * ```javascript\n   * query.return({\n   *   people: {\n   *     name: 'personName',\n   *     age: 'personAge',\n   *   },\n   * })\n   * // RETURN people.name as personName, people.age as personAge\n   * ```\n   *\n   * You can also pass an array of any of the above methods.\n   *\n   * The return method also accepts a `distinct` option which will cause a `RETURN DISTINCT` clause\n   * to be emitted instead.\n   * ```javascript\n   * query.return('people', { distinct: true })\n   * // RETURN DISTINCT people\n   * ```\n   */\n  return(terms: Many<Term>, options?: ReturnOptions) {\n    return this.continueChainClause(new Return(terms, options));\n  }\n\n  /**\n   * Shorthand for `return(terms, { distinct: true });\n   */\n  returnDistinct(terms: Many<Term>) {\n    return this.return(terms, { distinct: true });\n  }\n\n  /**\n   * Adds a [skip]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/skip}\n   * clause to the query.\n   *\n   * @param {string | number} amount\n   * @returns {Q}\n   */\n  skip(amount: number) {\n    return this.continueChainClause(new Skip(amount));\n  }\n\n  /**\n   * Add a [union]{@link https://neo4j.com/docs/cypher-manual/current/clauses/union/} clause to the\n   * query.\n   *\n   * ```javascript\n   * query.matchNode('people', 'People')\n   *   .return({ 'people.name': 'name' })\n   *   .union()\n   *   .matchNode('departments', 'Department')\n   *   .return({ 'departments.name': 'name' });\n   * // MATCH (people:People)\n   * // RETURN people.name AS name\n   * // UNION\n   * // MATCH (departments:Department)\n   * // RETURN departments.name AS name\n   * ```\n   */\n  union(all?: boolean) {\n    return this.continueChainClause(new Union(all));\n  }\n\n  /**\n   * Add a [union all]{@link https://neo4j.com/docs/cypher-manual/current/clauses/union/} clause to\n   * the query. Just shorthand for `union(true)`.\n   *\n   * ```javascript\n   * query.matchNode('people', 'People')\n   *   .return({ 'people.name': 'name' })\n   *   .unionAll()\n   *   .matchNode('departments', 'Department')\n   *   .return({ 'departments.name': 'name' });\n   * // MATCH (people:People)\n   * // RETURN people.name AS name\n   * // UNION ALL\n   * // MATCH (departments:Department)\n   * // RETURN departments.name AS name\n   * ```\n   */\n  unionAll() {\n    return this.continueChainClause(new Union(true));\n  }\n\n  /**\n   * Adds an [unwind]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/unwind}\n   * clause to the query.\n   *\n   * @param {any[]} list Any kind of array to unwind in the query\n   * @param {string} name Name of the variable to use in the unwinding\n   * @returns {Q}\n   */\n  unwind(list: any[], name: string) {\n    return this.continueChainClause(new Unwind(list, name));\n  }\n\n  /**\n   * Adds a [where]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/where}\n   * clause to the query.\n   *\n   * `where` is probably the most complex clause in this package because of the flexible ways to\n   * combine conditions. A handy rule of thumb is when you see an array it becomes an `OR` and when\n   * you see a dictionary, it becomes an `AND`. The many different ways of specifying your\n   * constraints are listed below.\n   *\n   * As a simple object, the comparison of each property is just `AND`ed together.\n   * ```javascript\n   * query.where({\n   *   name: 'Alan',\n   *   age: 54,\n   * })\n   * // WHERE name = 'Alan' AND age = 54\n   * ```\n   *\n   * You can wrap your constraints in a top level dictionary in which case the key of the outer\n   * dictionary will be considered the name of the node.\n   * ```javascript\n   * query.where({\n   *   person: {\n   *     name: 'Alan',\n   *     age: 54,\n   *   },\n   * })\n   * // WHERE person.name = 'Alan' AND person.age = 54\n   * ```\n   *\n   * Using an array, you can generate `OR`ed conditions.\n   * ```javascript\n   * query.where([\n   *   { name: 'Alan' },\n   *   { age: 54 },\n   * ])\n   * // WHERE name = 'Alan' OR age = 54\n   * ```\n   *\n   * Arrays can be placed at many levels in the conditions.\n   * ```javascript\n   * query.where({\n   *   name: [ 'Alan', 'Steve', 'Bob' ],\n   * })\n   * // WHERE name = 'Alan' OR name = 'Steve' OR name = 'Bob'\n   *\n   * query.where({\n   *   person: [\n   *     { name: 'Alan' },\n   *     { age: 54 },\n   *   ],\n   * })\n   * // WHERE person.name = 'Alan' OR person.age = 54\n   *\n   * query.where([\n   *   { employee: { name: 'Alan' } },\n   *   { department: { code: 765 } },\n   * })\n   * // WHERE employee.name = 'Alan' OR department.code = 765\n   * ```\n   *\n   * For more complex comparisons, you can use the comparator functions such as:\n   * ```javascript\n   * query.where({\n   *   age: greaterThan(30),\n   * })\n   * // WHERE age > 30\n   * ```\n   *\n   * The full list of comparators currently supported are:\n   *  - [between]{@link http://jamesfer.me/cypher-query-builder/globals.html#between}\n   *  - [contains]{@link http://jamesfer.me/cypher-query-builder/globals.html#contains}\n   *  - [endsWith]{@link http://jamesfer.me/cypher-query-builder/globals.html#endswith}\n   *  - [equals]{@link http://jamesfer.me/cypher-query-builder/globals.html#equals}\n   *  - [exists]{@link http://jamesfer.me/cypher-query-builder/globals.html#exists}\n   *  - [greaterEqualTo]{@link http://jamesfer.me/cypher-query-builder/globals.html#greaterequalto}\n   *  - [greaterThan]{@link http://jamesfer.me/cypher-query-builder/globals.html#greaterthan}\n   *  - [hasLabel]{@link http://jamesfer.me/cypher-query-builder/globals.html#haslabel}\n   *  - [inArray]{@link http://jamesfer.me/cypher-query-builder/globals.html#inarray}\n   *  - [isNull]{@link http://jamesfer.me/cypher-query-builder/globals.html#isnull}\n   *  - [lessEqualTo]{@link http://jamesfer.me/cypher-query-builder/globals.html#lessequalto}\n   *  - [lessThan]{@link http://jamesfer.me/cypher-query-builder/globals.html#lessthan}\n   *  - [regexp]{@link http://jamesfer.me/cypher-query-builder/globals.html#regexp}\n   *  - [startsWith]{@link http://jamesfer.me/cypher-query-builder/globals.html#startswith}\n   *\n   * You can import the comparisons one at a time or all at once.\n   * ```javascript\n   * import { greaterThan, regexp } from 'cypher-query-builder';\n   * // or\n   * import { comparisons } form 'cypher-query-builder';\n   * ```\n   *\n   * For convenience you can also pass a Javascript RegExp object as a value,\n   * which will then be converted into a string before it is passed to cypher.\n   * *However*, beware that the cypher regexp syntax is inherited from\n   * [java]{@link\n    * https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html},\n   * and may have slight differences to the Javascript syntax. If you would\n   * prefer, you can use the `regexp` comparator and use strings instead of\n   * RegExp objects. For example, Javascript RegExp flags will not be\n   * preserved when sent to cypher.\n   * ```javascript\n   * query.where({\n   *   name: /[A-Z].*son/,\n   * })\n   * // WHERE age =~ '[A-Z].*son'\n   * ```\n   *\n   * All the binary operators including `xor` and `not` are available as well and can also be\n   * imported individually or all at once.\n   * ```javascript\n   * import { xor, and } from 'cypher-query-builder';\n   * // or\n   * import { operators } form 'cypher-query-builder';\n   * ```\n   *\n   * The operators can be placed at any level of the query.\n   * ```javascript\n   * query.where({\n   *   age: xor([lessThan(12), greaterThan(65)])\n   * })\n   * // WHERE age < 12 XOR age > 65\n   * ```\n   *\n   * @param {AnyConditions} conditions\n   * @returns {Q}\n   */\n  where(conditions: AnyConditions) {\n    return this.continueChainClause(new Where(conditions));\n  }\n\n  /**\n   * Adds a [with]{@link https://neo4j.com/docs/developer-manual/current/cypher/clauses/with}\n   * clause to the query.\n   *\n   * There are many different ways to pass arguments to `with` so each is\n   * documented in turn below.\n   *\n   * A single string:\n   * ```javascript\n   * query.with('people')\n   * // WITH people\n   * ```\n   *\n   * An array of strings to return multiple variables:\n   * ```javascript\n   * query.with([ 'people', 'pets' ])\n   * // WITH people, pets\n   * ```\n   *\n   * A single object to rename variables:\n   * ```javascript\n   * query.with({ people: 'employees' })\n   * // WITH people AS employees\n   * ```\n   *\n   * A single object with an array for each value:\n   * ```javascript\n   * query.with({\n   *   people: [ 'name', 'age' ],\n   *   pets: [ 'name', 'breed' ],\n   * })\n   * // WITH people.name, people.age, pets.name, pets.breed\n   * ```\n   * This gives you a shortcut to specifying many node properties. You can also\n   * rename each property by adding an object inside the array or by providing\n   * an object as the value:\n   * ```javascript\n   * query.with({\n   *   people: [{ name: 'personName' }, 'age' ],\n   * })\n   * // WITH people.name as personName, people.age\n   * ```\n   * or\n   * ```javascript\n   * query.with({\n   *   people: {\n   *     name: 'personName',\n   *     age: 'personAge',\n   *   },\n   * })\n   * // WITH people.name as personName, people.age as personAge\n   * ```\n   *\n   * You can also pass an array of any of the above methods.\n   *\n   * @param {_.Many<Term>} terms\n   * @returns {Q}\n   */\n  with(terms: Many<Term>) {\n    return this.continueChainClause(new With(terms));\n  }\n}\n","import neo4j from 'neo4j-driver/lib/browser/neo4j-web';\nimport { Dictionary, map, mapValues, isArray } from 'lodash';\nimport { Record, Integer } from 'neo4j-driver/types/v1';\n\nexport type NeoValue = string | boolean | null | number | Integer;\nexport interface NeoNode {\n  identity: Integer;\n  labels: string[];\n  properties: Dictionary<NeoValue>;\n}\nexport interface NeoRelation {\n  identity: Integer;\n  start: Integer;\n  end: Integer;\n  type: string;\n  properties: Dictionary<NeoValue>;\n}\n\nexport type PlainValue = string | boolean | null | number;\nexport type PlainArray = string[] | boolean[] | number[];\nexport interface Node<P = Dictionary<PlainValue | PlainArray>> {\n  identity: string;\n  labels: string[];\n  properties: P;\n}\nexport interface Relation<P = Dictionary<PlainValue | PlainArray>> {\n  identity: string;\n  start: string;\n  end: string;\n  label: string;\n  properties: P;\n}\n\nexport class Transformer {\n  transformRecords<T= any>(records: Record[]): Dictionary<T>[] {\n    return map(records, rec => this.transformRecord(rec));\n  }\n\n  transformRecord<T = any>(record: Record): Dictionary<T> {\n    return mapValues(record.toObject() as any, node => this.transformValue(node));\n  }\n\n  private transformValue(value: any): any {\n    if (this.isPlainValue(value)) {\n      return value;\n    }\n    if (isArray(value)) {\n      return map(value, v => this.transformValue(v));\n    }\n    if (neo4j.isInt(value)) {\n      return this.convertInteger(value);\n    }\n    if (this.isNode(value)) {\n      return this.transformNode(value);\n    }\n    if (this.isRelation(value)) {\n      return this.transformRelation(value);\n    }\n    if (typeof value === 'object') {\n      return mapValues(value, v => this.transformValue(v));\n    }\n    return null;\n  }\n\n  private isPlainValue(value: any): value is PlainValue {\n    const type = typeof value;\n    return value == null || type === 'string' || type === 'boolean' || type === 'number';\n  }\n\n  private isNode(node: any): node is NeoNode {\n    return node !== null\n      && typeof node === 'object'\n      && !isArray(node)\n      && node.identity\n      && node.labels\n      && node.properties;\n  }\n\n  private transformNode(node: NeoNode): Node {\n    return {\n      identity: neo4j.integer.toString(node.identity),\n      labels: node.labels,\n      properties: mapValues(node.properties, this.transformValue.bind(this)),\n    };\n  }\n\n  private isRelation(rel: Dictionary<any>): rel is NeoRelation {\n    return rel.identity && rel.type && rel.properties && rel.start && rel.end;\n  }\n\n  private transformRelation(rel: NeoRelation): Relation {\n    return {\n      identity: neo4j.integer.toString(rel.identity),\n      start: neo4j.integer.toString(rel.start),\n      end: neo4j.integer.toString(rel.end),\n      label: rel.type,\n      properties: mapValues(rel.properties, this.transformValue.bind(this)),\n    };\n  }\n\n  private convertInteger(num: Integer) {\n    if (neo4j.integer.inSafeRange(num)) {\n      return neo4j.integer.toNumber(num);\n    }\n    return neo4j.integer.toString(num);\n  }\n}\n","import { map } from 'lodash';\nimport { Clause } from './clause';\n\nexport class ClauseCollection extends Clause {\n  protected clauses: Clause[] = [];\n\n  /**\n   * Returns all clauses in this collection.\n   * @returns {Clause[]}\n   */\n  getClauses(): Clause[] {\n    return this.clauses;\n  }\n\n  /**\n   * Adds a clause to the child list.\n   * @param {Clause} clause\n   */\n  addClause(clause: Clause) {\n    clause.useParameterBag(this.parameterBag);\n    this.clauses.push(clause);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  build() {\n    return `${map(this.clauses, s => s.build()).join('\\n')};`;\n  }\n}\n","// tslint:disable-next-line import-name\nimport AnyPromise from 'any-promise';\n// tslint:disable-next-line import-name\nimport Observable from 'any-observable';\nimport { Observable as RxObservable } from 'rxjs';\nimport { Dictionary } from 'lodash';\nimport { Connection, Observer } from './connection';\nimport { Builder } from './builder';\nimport { ClauseCollection } from './clause-collection';\nimport { Clause, QueryObject } from './clause';\n\nexport class Query extends Builder<Query> {\n  protected clauses = new ClauseCollection();\n\n  /**\n   * Creates a new query with a given connection.\n   *\n   * @param {Connection} connection\n   */\n  constructor(protected connection: Connection | null = null) {\n    super();\n  }\n\n  protected continueChainClause(clause: Clause) {\n    return this.addClause(clause);\n  }\n\n  /**\n   * Runs this query on its connection. If this query was created by calling a\n   * chainable method of a connection, then its connection was automatically\n   * set.\n   *\n   * Returns a promise that resolves to an array of records. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .run();\n   * ```\n   *\n   * Would result in the value:\n   * ```\n   * [\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // first friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // second friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // third friend,\n   *   },\n   * ]\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. If you use lodash you can extract all of Steve's friends from the\n   * results like using `_.map(results, 'friends')`. If you don't, you can use\n   * ES2015/ES6: `results.map(record => record.friends)`.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>[]`.\n   *\n   * Throws an exception if this query does not have a connection or has no\n   * clauses.\n   *\n   * @returns {Promise<Dictionary<R>[]>}\n   */\n  run<R = any>(): Promise<Dictionary<R>[]> {\n    if (!this.connection) {\n      return AnyPromise.reject(\n        new Error('Cannot run query; no connection object available.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    return this.connection.run<R>(this);\n  }\n\n  /**\n   * Runs this query on its connection. If this query was created by calling a\n   * chainable method of a connection, then its connection was automatically\n   * set.\n   *\n   * Returns an observable that emits each record as it is received from the\n   * database. This is the most efficient way of working with very large\n   * datasets. Each record is an object where each key is the name of a variable\n   * that you specified in your return clause.\n   *\n   * Eg:\n   * ```typescript\n   * const result$ = connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .stream();\n   *\n   * // Emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // Then emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // And so on\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. You can extract all of steve's friends from the query by using RxJS\n   * operators:\n   * ```\n   * const friends$ = results$.map(row => row.friends);\n   * ```\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Observable<Dictionary<R>>`.\n   *\n   * Throws an exception if this query does not have a connection or has no\n   * clauses.\n   */\n  stream<R = any>(): RxObservable<Dictionary<R>> {\n    if (!this.connection) {\n      return new Observable((subscriber: Observer<Dictionary<R>>): void => {\n        subscriber.error(new Error('Cannot run query; no connection object available.'));\n      });\n    }\n\n    return this.connection.stream<R>(this);\n  }\n\n  /**\n   * Runs the current query on its connection and returns the first result.\n   * If the query was created by calling a chainable method of a connection,\n   * the query's connection was automatically set.\n   *\n   * If 0 results were returned from the database, returns `undefined`.\n   *\n   * Returns a promise that resolves to a single record. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>`. Note that this function returns\n   * `undefined` if the result set was empty.\n   */\n  first<R = any>(): Promise<Dictionary<R> | undefined> {\n    return this.run<R>().then(results => results && results.length > 0 ? results[0] : undefined);\n  }\n\n  // Clause proxied methods\n\n  /**\n   * Returns the query as a string with parameter variables.\n   *\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .build();\n   *\n   * // MATCH (steve { name: $name })-[:FriendsWith]->(friends)\n   * // RETURN steve, friends\n   * ```\n   *\n   * @returns {string}\n   */\n  build(): string {\n    return this.clauses.build();\n  }\n\n  /**\n   * Synonym for `build()`.\n   * @returns {string}\n   */\n  toString(): string {\n    return this.clauses.toString();\n  }\n\n  /**\n   * Returns an object that includes both the query and the params ready to be\n   * passed to the neo4j driver.\n   */\n  buildQueryObject(): QueryObject {\n    return this.clauses.buildQueryObject();\n  }\n\n  /**\n   * Like `build`, but will insert the values of the parameters into the string\n   * so queries are easier to debug. __Note: this should only ever be used for\n   * debugging__.\n   *\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .build();\n   *\n   * // MATCH (steve { name: 'Steve' })-[:FriendsWith]->(friends)\n   * // RETURN steve, friends\n   * ```\n   *\n   * @returns {string}\n   */\n  interpolate(): string {\n    return this.clauses.interpolate();\n  }\n\n  /**\n   * Returns an array of all the clauses in this query.\n   * @returns {Clause[]}\n   */\n  getClauses(): Clause[] {\n    return this.clauses.getClauses();\n  }\n\n  /**\n   * Adds a new clause to the query. You probably won't ever need to call this\n   * directly, but there is nothing stopping you.\n   *\n   * @param {Clause} clause\n   * @returns {this}\n   */\n  addClause(clause: Clause): this {\n    this.clauses.addClause(clause);\n    return this;\n  }\n}\n","// tslint:disable-next-line import-name\nimport AnyPromise from 'any-promise';\n// tslint:disable-next-line import-name\nimport Observable from 'any-observable';\n// import nodeCleanup from 'node-cleanup';\nimport { Dictionary, isFunction } from 'lodash';\nimport { AuthToken, Config, Driver, Session } from 'neo4j-driver/types/v1';\nimport { Transformer } from './transformer';\nimport { Query } from './query';\nimport neo4j from 'neo4j-driver/lib/browser/neo4j-web';\nimport { Builder } from './builder';\nimport { Clause } from './clause';\n\nlet connections: Connection[] = [];\n\n// Closes all open connections\n// nodeCleanup(() => {\n//   connections.forEach(con => con.close());\n//   connections = [];\n// });\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (error: any) => void;\n  complete: () => void;\n}\n\nexport type DriverConstructor = typeof neo4j.driver;\n\nexport interface FullConnectionOptions {\n  driverConstructor: DriverConstructor;\n  driverConfig: Config;\n}\n\nexport type ConnectionOptions = Partial<FullConnectionOptions>;\n\nexport interface Credentials { username: string; password: string; }\n\nfunction isCredentials(credentials: any): credentials is Credentials {\n  return 'username' in credentials && 'password' in credentials;\n}\n\n// We have to correct the type of lodash's isFunction method because it doesn't correctly narrow\n// union types such as the options parameter passed to the connection constructor.\nconst isTrueFunction: (value: any) => value is Function = isFunction;\n\n// tslint:disable max-line-length\n/**\n * The Connection class lets you access the Neo4j server and run queries against it. Under the hood,\n * the Connection class uses the official Neo4j Nodejs driver which manages connection pooling on a\n * [session basis]{@link https://neo4j.com/docs/api/javascript-driver/current/class/src/v1/driver.js~Driver.html#instance-method-session}.\n * It should be enough to have a single Connection instance per database per application.\n *\n * To create the connection, simply call the\n * [constructor]{@link https://jamesfer.me/cypher-query-builder/classes/connection.html#constructor}\n * and pass in the database url, username and password.\n * ```\n * const db = new Connection('bolt://localhost', {\n *   username: 'neo4j',\n *   password: 'password',\n * })\n * ```\n *\n * To use the connection, just start calling any of the clause methods such as `match`, `create` or\n * `matchNode` etc. They automatically create a {@link Query} object that you can then chain other\n * methods off of.\n * ```\n * db.matchNode('people', 'Person')\n *   .where({ 'people.age': greaterThan(18) })\n *   .return('people')\n *   .run()\n * ```\n *\n * You can also pass a query to the\n * [run]{@link https://jamesfer.me/cypher-query-builder/classes/connection.html#run} method,\n * however, this is probably much less convenient.\n * ```\n * db.run(\n *   new Query().matchNode('people', 'Person')\n *     .where({ 'people.age': greaterThan(18) })\n *     .return('people')\n *     .run()\n * );\n * ```\n *\n * Once you've finished with the connection you should close the connection.\n * ```\n * db.close()\n * ```\n *\n * The library will attempt to clean up all connections when the process exits, but it is better to\n * be explicit.\n */\n// tslint:enable max-line-length\nexport class Connection extends Builder<Query> {\n  protected auth: AuthToken;\n  protected driver: Driver;\n  protected options: FullConnectionOptions;\n  protected open: boolean;\n  protected transformer = new Transformer();\n\n  /**\n   * Creates a new connection to the database.\n   *\n   * @param url Url of the database such as `'bolt://localhost'`\n   * @param auth Auth can either be an object in the form `{ username: ..., password: ... }`, or a\n   * Neo4j AuthToken object which contains the `scheme`, `principal` and `credentials` properties\n   * for more advanced authentication scenarios. The AuthToken object is what is passed directly to\n   * the neo4j javascript driver so checkout their docs for more information on it.\n   * @param options Additional configuration options. If you provide a function instead of an\n   * object, it will be used as the driver constructor. While passing a driver constructor function\n   * here is not deprecated, it is the legacy way of setting it and you should prefer to pass an\n   * options object with the `driverConstructor` parameter.\n   * @param options.driverConstructor An optional driver constructor to use for\n   * this connection. Defaults to the official Neo4j driver. The constructor is\n   * given the url you pass to this constructor and an auth token that is\n   * generated from calling [`neo4j.auth.basic`]{@link\n   * https://neo4j.com/docs/api/javascript-driver/current#usage-examples}.\n   * @param options.driverConfig Neo4j options that are passed directly to the underlying driver.\n   */\n  constructor(\n    protected url: string,\n    auth: Credentials | AuthToken,\n    options: DriverConstructor | ConnectionOptions = neo4j.driver,\n  ) {\n    super();\n\n    this.auth = isCredentials(auth)\n      ? neo4j.auth.basic(auth.username, auth.password)\n      : auth;\n\n    const driverConstructor = isTrueFunction(options) ? options\n      : options.driverConstructor ? options.driverConstructor : neo4j.driver;\n    const driverConfig = isTrueFunction(options) || !options.driverConfig\n      ? {} : options.driverConfig;\n    this.options = { driverConstructor, driverConfig };\n    this.driver = driverConstructor(this.url, this.auth, this.options.driverConfig);\n    this.open = true;\n    connections.push(this);\n  }\n\n  /**\n   * Closes this connection if it is open. Closed connections cannot be\n   * reopened.\n   */\n  close() {\n    if (this.open) {\n      this.driver.close();\n      this.open = false;\n    }\n  }\n\n  /**\n   * Opens and returns a session. You should never need to use this directly.\n   * Your probably better off with `run` instead.\n   */\n  session(): Session | null {\n    if (this.open) {\n      return this.driver.session();\n    }\n    return null;\n  }\n\n  /**\n   * Returns a new query that uses this connection. The methods such as `match`\n   * or `create` are probably more useful to you as they automatically create a\n   * new chainable query for you.\n   * @return {Query}\n   */\n  query(): Query {\n    return new Query(this);\n  }\n\n  protected continueChainClause(clause: Clause) {\n    return this.query().addClause(clause);\n  }\n\n  /**\n   * Runs the provided query on this connection, regardless of which connection\n   * the query was created from. Each query is run on it's own session.\n   *\n   * Run returns a promise that resolves to an array of records. Each key of the\n   * record is the name of a variable that you specified in your `RETURN`\n   * clause.\n   * Eg:\n   * ```typescript\n   * connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .run();\n   * ```\n   *\n   * Would result in the value:\n   * ```\n   * [\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // first friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // second friend,\n   *   },\n   *   {\n   *     steve: { ... } // steve node,\n   *     friends: { ... } // third friend,\n   *   },\n   * ]\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. If you use lodash you can extract all of Steve's friends from the\n   * results like using `_.map(results, 'friends')`. If you don't, you can use\n   * ES2015/ES6: `results.map(record => record.friends)`.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>[]`.\n   *\n   * Throws an exception if this connection is not open or there are no clauses\n   * in the query.\n   *\n   * @param {Query} query\n   * @returns {Promise<Dictionary<R>[]>}\n   */\n  run<R = any>(query: Query): Promise<Dictionary<R>[]> {\n    if (!this.open) {\n      return AnyPromise.reject(\n        new Error('Cannot run query; connection is not open.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    if (query.getClauses().length === 0) {\n      return AnyPromise.reject(\n        new Error('Cannot run query: no clauses attached to the query.'),\n      ) as Promise<Dictionary<R>[]>;\n    }\n\n    const session = this.session();\n    if (!session) {\n      throw Error('Cannot run query: connection is not open.');\n    }\n\n    const queryObj = query.buildQueryObject();\n    const result = session.run(queryObj.query, queryObj.params);\n\n    // Need to wrap promise in an any-promise\n    return AnyPromise.resolve(result)\n      .then((result) => {\n        session.close();\n        return this.transformer.transformRecords<R>(result.records);\n      })\n      .catch((error) => {\n        session.close();\n        return Promise.reject(error);\n      }) as Promise<Dictionary<R>[]>;\n  }\n\n  /**\n   * Runs the provided query on this connection, regardless of which connection\n   * the query was created from. Each query is run on it's own session.\n   *\n   * Returns an observable that emits each record as it is received from the\n   * database. This is the most efficient way of working with very large\n   * datasets. Each record is an object where each key is the name of a variable\n   * that you specified in your return clause.\n   *\n   * Eg:\n   * ```typescript\n   * const results$ = connection.match([\n   *   node('steve', { name: 'Steve' }),\n   *   relation('out', [ 'FriendsWith' ]),\n   *   node('friends'),\n   * ])\n   *   .return([ 'steve', 'friends' ])\n   *   .stream();\n   *\n   * // Emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // Then emits\n   * // {\n   * //   steve: { ... } // steve node,\n   * //   friends: { ... } // first friend,\n   * // },\n   * // And so on\n   * ```\n   *\n   * Notice how the steve record is returned for each row, this is how cypher\n   * works. You can extract all of steve's friends from the query by using\n   * operators:\n   * ```\n   * const friends$ = results$.map(row => row.friends);\n   * ```\n   *\n   * The observable class that is used is imported from\n   * [any-observable](https://github.com/sindresorhus/any-observable) by default\n   * it uses rxjs for the observables, but you can pick a different implementation\n   * by registering it with any-observable before importing this module.\n   *\n   * If you use typescript you can use the type parameter to hint at the type of\n   * the return value which is `Dictionary<R>`.\n   *\n   * Throws an exception if this connection is not open or there are no clauses\n   * in the query.\n   *\n   * The query is run when you call stream so you should subscribe to the results\n   * immediately to prevent missing any data.\n   *\n   * Due to the way the Neo4j javascript driver works, once you call stream there\n   * is no way to stop the query until it is complete. Even if you unsubscribe from\n   * the observable, all the remaining rows will still be parsed by the driver but\n   * then immediately discarded.\n   * ```typescript\n   * const results$ = connection.matchNode('records')\n   *   .return('records')\n   *   .limit(1000) // 1000 records will be loaded and parsed from the database\n   *   .stream()\n   *   .take(10) // even though you only take the first 10\n   *   .subscribe(record => {});\n   * ```\n   * In practice this should never happen unless you're doing some strange things.\n   */\n  stream<R = any>(query: Query): Observable<Dictionary<R>> {\n    return new Observable((subscriber: Observer<Dictionary<R>>): void => {\n      if (!this.open) {\n        subscriber.error(new Error('Cannot run query; connection is not open.'));\n        return;\n      }\n\n      if (query.getClauses().length === 0) {\n        subscriber.error(Error('Cannot run query: no clauses attached to the query.'));\n        return;\n      }\n\n      const session = this.session();\n      if (!session) {\n        throw Error('Cannot run query: connection is not open.');\n      }\n\n      // Run the query\n      const queryObj = query.buildQueryObject();\n      const result = session.run(queryObj.query, queryObj.params);\n\n      // Subscribe to the result and clean up the session\n      // Note: Neo4j observables use a different subscribe syntax to RxJS observables\n      result.subscribe({\n        onNext: (record) => {\n          if (!subscriber.closed) {\n            subscriber.next(this.transformer.transformRecord<R>(record));\n          }\n        },\n        onError: (error) => {\n          session.close();\n          if (!subscriber.closed) {\n            subscriber.error(error);\n          }\n        },\n        onCompleted: () => {\n          session.close();\n          if (!subscriber.closed) {\n            subscriber.complete();\n          }\n        },\n      });\n    });\n  }\n}\n"],"names":["uniqueString","str","existing","camelString","number","matches","match","substr","length","regex","RegExp","takenSuffixes","suffixes","existingString","suffix","push","indexOf","Math","max","stringifyValue","value","join","pairs","el","key","stringifyLabels","labels","relation","stringifyPathLength","bounds","lower","upper","name","Parameter","ParameterBag","parameterMap","actualName","getName","param","other","addExistingParam","ParameterContainer","newBag","importParams","parameterBag","getParams","addParam","__extends","Clause","build","query","params","pattern","replace","conditions","options","expanded","_super","_this","isConditions","a","tempName","tempLabels","tempConditions","undefined","TypeError","setExpandedConditions","Pattern","useExpandedConditions","rebindConditionParams","conditionParams","deleteParam","strings","toString","NodePattern","getNameString","getLabelsString","getConditionsParamString","isPathLengthArray","item","isPathLength","dir","tempLength","RelationPattern","arrows","in","out","either","patterns","defaultOptions","arr","forEach","pat","useParameterBag","PatternClause","patternStrings","clause","Create","unique","terms","TermListClause","term","stringifyTerm","stringifyProperty","stringifyProperties","stringifyDictionary","prop","alias","node","prefix","props","convertToString","list","With","listParam","Unwind","variables","Delete","detach","_a","values","valueIsObject","op","merge","operationStrings","Set","makeLabelStatement","makeValueStatement","makeVariableStatement","optional","Match","_b","_c","properties","Remove","property","__spreadArrays","Return","distinct","amount","amountParam","Skip","Limit","comparisions","equals","greaterThan","greaterEqualTo","lessThan","lessEqualTo","startsWith","endsWith","contains","inArray","hasLabel","exists","between","isNull","regexp","compare","operator","variable","paramName","baseParamName","split","parts","exp","insensitive","stringExp","lowerInclusive","upperInclusive","lowerOp","upperOp","lowerComparator","upperComparator","lowerConstraint","upperConstraint","label","Precedence","stringifyCondition","condition","conditionName","stringCons","precedence","None","combineOr","combineAnd","WhereOp","evaluate","combineNot","string","Not","braces","newPrecedence","Or","combineXor","Xor","namePrefix","And","Where","_i","args","Object","hasOwnProperty","call","queryParams","Raw","fields","direction","OrderBy","normalizeDirection","constraints","field","fieldDirection","upperDir","toUpperCase","isDescending","Merge","OnMatch","OnCreate","operators","and","or","xor","not","WhereAnd","WhereOr","WhereXor","WhereNot","all","Union","chain","wrapper","SetBlock","wrap","c","continueChainClause","bind","Builder","create","createNode","return","Transformer","records","rec","transformRecord","record","toObject","transformValue","isPlainValue","v","neo4j","isInt","convertInteger","isNode","transformNode","isRelation","transformRelation","type","identity","integer","rel","start","end","num","inSafeRange","toNumber","ClauseCollection","clauses","s","connection","Query","addClause","AnyPromise","reject","Error","run","Observable","subscriber","error","stream","then","results","buildQueryObject","interpolate","getClauses","isCredentials","credentials","isTrueFunction","url","auth","driver","basic","username","password","driverConstructor","driverConfig","open","connections","Connection","close","session","queryObj","result","resolve","transformer","transformRecords","catch","Promise","subscribe","onNext","closed","next","onError","onCompleted","complete"],"mappings":"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"}